<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Chapter 15</title>
  <style>
      html, body {
          background-color: #000000;
          color: #FFFFFF;
      }
  </style>
</head>
<body>
<h2 id="gameplay-systems">Gameplay Systems</h2>
<p>Manage things such as:</p>
<ul>
<li>Interaction rules between objects</li>
<li>Player objectives</li>
<li>success/fail criteria</li>
<li>Player abilities</li>
<li>overall flow</li>
<li>number and types of non-player entities</li>
</ul>
<p>Sometimes referred to as &quot;game mechanics&quot;, &quot;G-factor&quot;</p>
<h2 id="game-world-elements">Game world elements</h2>
<ul>
<li>Static Elements:<ul>
<li>don&#39;t change or interact with things during gameplay</li>
<li>terrain, buildings, roads, bridges</li>
<li>Allows for optimization since we don&#39;t have to worry about
alot of logic for managing these</li>
<li>Static geometry</li>
<li>Brush geometry: a shape made up of a collection of convex
volumes, easy to make and used for prototyping</li>
</ul>
</li>
<li>Dynamic elements:<ul>
<li>Objects/elements that can change/interact with each other</li>
<li>characters, vehicles, weaponry, floating power-ups
and health packs, collectible objects, particle emitters, dynamic lights</li>
</ul>
</li>
<li><img src="static_dynamic.png" alt="Static and Dynamic"></li>
</ul>
<h2 id="world-chunks">World Chunks</h2>
<ul>
<li>Split up the world into multiple sections<ul>
<li>Such as levels, world areas, etc.</li>
</ul>
</li>
<li>Helps memory usage/resources since don&#39;t have to load everything
at once</li>
<li><img src="world_chunks.png" alt="World Chunks"></li>
<li><img src="world_chunk_graph.png" alt="World Chunk Graph"></li>
</ul>
<h2 id="game-objects">Game Objects</h2>
<ul>
<li>Referred to as GO</li>
<li>An object-oriented model, uses inheritance</li>
<li>Can be instanced; each has a type:<ul>
<li>Pacman has 1 pacman instance, 5 ghost instances,
and 100 pellet instances</li>
</ul>
</li>
<li>The &quot;object model&quot; can define the C++ interface or
by a formal design language, such as the OMT object model<ul>
<li>Microsoft Excel has an object model which allows external
programs to control excel (API/interface)</li>
</ul>
</li>
</ul>
<h2 id="tool-side-vs-runtime-design">Tool side vs Runtime design</h2>
<ul>
<li>Tools for creation might have their own interface/language/model
different from the game engine, which is converted during the
asset conversion pipeline</li>
<li>The  tool-side object model is defined by the set of game object types seen by
the designers within the world editor.</li>
<li>The runtime object model is the model used by the engine/language
used during runtime</li>
</ul>
<h2 id="data-driven-game-engine">Data-driven game engine</h2>
<ul>
<li>Much of the logic/work in an object/asset is defined and
implemented at the tool-side/asset creation stage.</li>
<li>The engine supports reading the tool-side logic/is 
abstracted to read,parse,run what is defined within
the data itself</li>
<li>This requires extra work on the engine side in terms
of implementation, however can pay off by the improved
&quot;iteration time&quot; from the asset developer<ul>
<li>Iteration time = time needed between modifying an
asset and seeing the result in the game</li>
</ul>
</li>
<li>Need to be careful when trying to implement this as it
can be time consuming, complex, and bug ridden; may
be easier to hard code stuff</li>
</ul>
<h2 id="game-world-editor-examples">Game world editor examples</h2>
<ul>
<li>Radiant from Quake/Doom engines<ul>
<li><img src="radiant_editor.png" alt="Radiant Editor"></li>
</ul>
</li>
<li>Hammer (prev. called Worldcraft, The Forge) from Source engine from Valve<ul>
<li><img src="hammer_editor.png" alt="Hammer Editor"></li>
</ul>
</li>
<li>CRYENGINE from crytek<ul>
<li><img src="cryengine_editor.png" alt="Cryengine editor"></li>
</ul>
</li>
</ul>
<h2 id="game-world-editor-features">Game world editor features</h2>
<ul>
<li>World chunk creation/management</li>
<li>Perspective/Orthogonal world views</li>
<li>Navigation, e.g. via WASD, object centering</li>
<li>Object selection via raycasts or rubber-band select</li>
<li>Property Grids: Show and modify object properties<ul>
<li><img src="property_grid.png" alt="Property Grid"></li>
</ul>
</li>
<li>Light Objects</li>
<li>Particle Emitteres</li>
<li>Sound Sources</li>
<li>Event Regions</li>
<li>Splines: Catmull-Rom splines commonly used</li>
<li>AI Nav Meshes: define areas the AI can navigate through</li>
<li>Custom Data</li>
<li>Save/Load in formats such as binary, JSON, XML</li>
<li>Rapid Iteration/Round Trip Time: want quick time between
change and viewing the result</li>
</ul>
</body>
</html>
