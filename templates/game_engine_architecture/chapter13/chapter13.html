<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Chapter 13</title>
</head>
<body>

<h2 id="popular-collision-and-physics-libraries">Popular Collision and Physics Libraries</h2>
<ul>
<li><strong><a href="http://www.ode.org/"><img src="ode.png" alt="ODE" width="200px"></a></strong></li>
<li><strong><a href="https://pybullet.org/wordpress/index.php/forum-2/">Bullet</a></strong></li>
<li><strong><a href="http://trueaxis.com/"><img src="trueaxis.jpg" width="200px" alt="TrueAxis"></a></strong></li>
<li><strong><a href="https://developer.nvidia.com/gameworks-physx-overview"><img src="physx.jpg" alt="PhysX" width="200px"></a></strong></li>
<li><strong><a href="http://www.havok.com"><img src="havok.png" alt="Havok" width="200px"></a></strong></li>
<li><strong><a href="http://www.adrianboeing.com/pal/index.html"><img src="pal.gif" alt="Physics Abstraction Layer (PAL)" width="200px"></a></strong></li>
<li><strong><a href="http://www.pixeluxentertainment.com"><img src="dmm.png" alt="Digital Molecular Matter (DMM)" width="200px" style="background-color:black;"></a></strong></li>
</ul>
<h2 id="collidable-representation">Collidable Representation</h2>
<ul>
<li>The intersection shapes/primitives for an object in the scene are stored via its own
geometry and transformation (its &#39;collision representation&#39;)</li>
<li>Some common intersectable shapes used include<ul>
<li>sphere</li>
<li>capsule</li>
<li>Axis Aligned Bounding Box (AABB)</li>
<li>Discrete Oriented Polytopes (DOP)<ul>
<li><img src="dop.png" alt="DOP"></li>
</ul>
</li>
<li>Polygon Soup (Poly Soup)</li>
</ul>
</li>
<li>These are also called &#39;collision volumes&#39;</li>
<li>Scene objects can contain multiple collision primitives
representing them (e.g. a chair can be represented by a cube
and a triangular prism)<ul>
<li><img src="chair_example.png" alt="Chair"></li>
<li>This can also be used for early-termination checking:
a coarse check of a larger,wrapping primitive can be
used as an easy first-check for intersection<ul>
<li><img src="early_test.png" alt="Early Test"></li>
</ul>
</li>
</ul>
</li>
<li>Usually the collision engine contains a &#39;collision/physics world&#39;
in which all collidable objects are represented<ul>
<li>benefit of cache coherency</li>
</ul>
</li>
</ul>
<h2 id="convex-concave">Convex/Concave</h2>
<ul>
<li>Usually convex shapes are used as a line can only enter
and exit a convex shape once (concave adds more complexity)<ul>
<li>If a concave shape is shrink-wrapped, there will be air
pockets; convex shapes will have NO air pockets when
shrink wrapped</li>
</ul>
</li>
</ul>
<h2 id="poly-soup">Poly Soup</h2>
<ul>
<li>A collection of non-convex shapes, not necessarily enclosed
or in a &#39;shape&#39; form</li>
<li>Used to represent complex static geometry like terrain and buildings<ul>
<li><img src="poly_soup.png" alt="Poly Soup"></li>
</ul>
</li>
<li>Front-face is used to represent &#39;outside&#39; (via stored winding
order) and back-face represents &#39;inside&#39;</li>
</ul>
<h2 id="sphere-intersection-test">Sphere intersection test</h2>
<ul>
<li><strong>s</strong> = <strong>c</strong> - <strong>p</strong></li>
<li>if |<strong>s</strong>| &lt;= <em>r</em>, then <strong>p</strong> is inside the sphere<ul>
<li><strong>c</strong> = sphere center, <strong>p</strong> = test point, <em>r</em> = sphere radius</li>
</ul>
</li>
</ul>
<h2 id="sphere-intersecting-other-sphere-test">Sphere intersecting other sphere test</h2>
<ul>
<li><strong>s</strong> = <strong>c1</strong> - <strong>c2</strong></li>
<li>if |<strong>s</strong>|<sup>2</sup> &lt;= (<em>r1</em> + <em>r2</em>)<sup>2</sup>, then
the spheres intersect<ul>
<li>Difference squared is used to prevent square root calculation (|<strong>s</strong>|)
for performance</li>
</ul>
</li>
</ul>
<h2 id="separating-axis-theorem">Separating axis theorem</h2>
<ul>
<li>If there is a line that can separate the projection of 
two convex shapes, then they do not intersect</li>
<li><img src="separating_axis_theorem.png" alt="Separating Axis"></li>
<li><img src="sphere_axis_theorem.png" alt="Sphere Separating Axis"></li>
</ul>
<h2 id="gjk-algorithm">GJK Algorithm</h2>
<ul>
<li>Works for intersection testing between arbitrary polytopes
(convex polygons in 2d, convex polyhedra in 3d)</li>
<li><a href="http://mollyrocket.com/849">http://mollyrocket.com/849</a></li>
<li>Uses the &#39;minkowski difference&#39;<ul>
<li>Takes difference between all points within shape A and B</li>
</ul>
</li>
<li>If the set contains the origin point, then the shapes intersect<ul>
<li>since any point minus itself is 0 or the origin</li>
</ul>
</li>
<li>The minkowski difference between two convex shapes is also a
convex shape<ul>
<li><img src="minkowski_shape.png" alt="Minkowski Shape"></li>
</ul>
</li>
<li>Attempts to create a tetrahedron that surrounds the origin from
the minkowski difference set</li>
<li>If this tetrahdron cannot be created, then the shapes do not intersect</li>
<li><img src="tetrahedron.png" alt="Tetrahedron">  </li>
<li><img src="minkowski_tetrahedron.png" alt="Minkowski Tetrahedron"></li>
</ul>
<h2 id="paper-bullet-problem-tunneling-">Paper Bullet Problem (Tunneling)</h2>
<ul>
<li>If an object is moving faster than its size each, it can
&quot;skip over&quot; an intersection<ul>
<li><img src="paper_bullet.png" alt="Paper Bullet"></li>
</ul>
</li>
<li>Can be solved via<ul>
<li>Swept Shapes: create a new shape as the combination
of the previous and next frame<ul>
<li><img src="swept_shapes.png" alt="Swept Shapes"></li>
<li>Only works well for moving in a straight line</li>
</ul>
</li>
<li>Continuous Collision Detection (CCD)<ul>
<li>Finds the earliest &#39;Time of Impact&#39; (TOI) between
two objects over a time interval</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="performance-optimizations">Performance Optimizations</h2>
<ul>
<li>Collision detection can be expensive, esp. if you check
every possible object with each other (O(n<sup>2</sup>))</li>
<li>Can use techniques we&#39;ve seen before in the render
such as spacial partitioning<ul>
<li>Octtrees</li>
<li>Binary Space Parititioning Trees (BSPs)</li>
<li>etc.</li>
</ul>
</li>
<li>Other techniques:<ul>
<li>Temporal Coherency (Save calculated values that haven&#39;t
changed from the previous frame)</li>
<li>Broad Phase, Midphase, and Narrow Phase<ul>
<li>Broad Phase: Use AABBs to determine which collidables
are potentially intersecting</li>
<li>Midphase: Use coarse bounding volumes, such as spheres
for another early termination step</li>
<li>Narrow Phase: Use the individual primitives for
the closest/specific possible collision detection</li>
</ul>
</li>
<li>Sweep and Prune algorithm<ul>
<li>sort the minimum and maximum dimensions of the AABBs
along the x,y,z axes then check for intersection
along the sorted list</li>
<li>Can reduce O(n log n) to O(n)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="collision-queries">Collision Queries</h2>
<ul>
<li>Most physics engines support checking things such as
&quot;What is the earliest intersection if I move this character
 in this direction&quot; or &quot;find all enemy objects within this 
 radius&quot;</li>
</ul>
<h2 id="raycasting">Raycasting</h2>
<ul>
<li>Have paramtetric line segment p(t) = p0 + td, 0&lt;=t&lt;=1</li>
<li>Check for intersection along this line</li>
<li>Example ray casting usage: check for line of sight
from an AI to the character by ray casting from the
AI point of view to the main characters chest, and seeing
if any intersections get in the way</li>
</ul>
<h2 id="shape-casting">Shape Casting</h2>
<ul>
<li>Move a collision volume along a parametric line segment
and check for intersections along the way</li>
<li>This is more complex as you can have multiple
collision points at the same time; usually returns 
an array of collisions</li>
<li><img src="shape_cast_1.png" alt="Shape Cast 1"></li>
<li><img src="shape_cast_2.png" alt="Shape Cast 2"></li>
<li>Can be used to move 3d objects, and do things like
automatically move up a curb or move left/right against
a wall</li>
</ul>
<h2 id="phantoms">Phantoms</h2>
<ul>
<li>Collision objects which can intersect with regular objects,
but regular objects cannot collide with them</li>
<li>regular collisions with a phantom are ignored, but a phantom
can still collide with regular objects</li>
</ul>
<h2 id="collision-filtering">Collision Filtering</h2>
<ul>
<li>Ability to group collision types together to only
check between collisions of the same types<ul>
<li>Uses masking or layers (e.g. a grouping bitmask)</li>
</ul>
</li>
<li>Also ability to turn collision on/off for an object</li>
</ul>
<h2 id="collision-materials">Collision Materials</h2>
<ul>
<li>Holds information such as friction, sound effects,
particle effects, etc. for an object types such as skin,
wood, metal, etc.</li>
</ul>

TODO - left off on 13.4 Rigid Body Dynamics

</body>
</html>
