<!-- code samples from the book can be found here:
     https://sites.google.com/site/webglbook/
-->
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <title>41 Multiple Segments</title>
</head>
<body onload="main()">
<canvas id="mycanvas" width="600" height="600">
    Your Browser doesn't support canvas :(
</canvas>
<p>Use up/down/left/right, z/x/c/v keys to rotate!</p>

<script src="../lib/webgl-utils.js"></script>
<script src="../lib/webgl-debug.js"></script>
<script src="../lib/cuon-utils.js"></script>
<script src="../lib/cuon-matrix.js"></script>

<script>
    
// vertex shader program
var VertexShaderStr =`
    attribute vec4 aPosition; // vertex data passed into the shader
    attribute vec4 aColor;
    attribute vec4 aNormal;
    
    uniform mat4 uModelMatrix;
    uniform mat4 uNormalMatrix; // inverse transpose of the model matrix
    uniform mat4 uViewMatrix;
    uniform mat4 uProjectionMatrix;
    
    varying vec4 vColor; // for lighting calculation
    varying vec3 vNormal;
    varying vec3 vPosition;
    
    void main() {
        gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * aPosition; // coordinates
        
        vPosition = vec3(uModelMatrix * aPosition); // world space vertex coord
        vNormal = normalize(vec3(uNormalMatrix * aNormal));
        vColor = aColor;
    }
`;

// fragment shader program
var FragmentShaderStr = `
    precision mediump float;
    
    uniform vec3 uLightColor;
    uniform vec3 uLightPosition;
    uniform vec3 uAmbientColor;
    
    varying vec4 vColor; // passed from vertex shader
    varying vec3 vNormal;
    varying vec3 vPosition;
    
    // point light
    vec3 calcPoint() {
    
        // normalize input
        vec3 normal = normalize(vNormal);
        
        // normalized light direction
        vec3 lightDir = normalize(uLightPosition - vPosition);
        
        // diffuse dot product
        float nDotL = max(dot(normal, lightDir), 0.0);
        
        // diffuse calculation
        vec3 diffuse = uLightColor * vec3(vColor) * nDotL;
        
        return diffuse;
    }
    
    vec3 calcAmbient() {
        return uAmbientColor * vec3(vColor);
    }
    
    void main() {
        //gl_FragColor = vColor;
        gl_FragColor = vec4(calcPoint() + calcAmbient(), 1.0);
    }
`;

// global object buffers
var baseBuffer = null;
var arm1Buffer = null;
var arm2Buffer = null;
var palmBuffer = null;
var fingerBuffer = null;
// shader attrib for the above buffer vertices
var aPosition = null;

function main() {
    
    // retrieve the canvas element
    var canvas = document.getElementById("mycanvas");
    
    if (!canvas) {
        console.log("Failed to get canvas element");
        return false;
    }
    
    var gl = getWebGLContext(canvas);
    if (!gl) {
        console.log("Failed to get OpenGL context");
        return false;
    }
    
    // Load and compile shader programs
    if (!initShaders(gl, VertexShaderStr, FragmentShaderStr)) {
        console.log("Failed to init shaders");
        return false;
    }
    
    // create the object buffers
    var n = initVertexBuffers(gl); // n = number of vertices
    if (n < 0) {
        console.log("Failed to set positions of the vertices");
        return false;
    }
    
    // enable checking depth before drawing
    // try commenting out to see what happens
    gl.enable(gl.DEPTH_TEST);
    
    // enable offset to mitigate z fighting
    //gl.enable(gl.POLYGON_OFFSET_FILL);
    //gl.polygonOffset(1.0, 1.0);
    
    // set lighting uniforms
    var uLightColor = gl.getUniformLocation(gl.program, "uLightColor");
    var uLightPosition = gl.getUniformLocation(gl.program, "uLightPosition");
    var uAmbientColor = gl.getUniformLocation(gl.program, "uAmbientColor");
    if (uLightColor < 0 ||
        uLightPosition < 0 ||
        uAmbientColor < 0) {
        console.log("Error getting light uniforms");
        return false;
    }
    gl.uniform3f(uLightColor, 1.0, 1.0, 1.0);
    var lightPosition = new Vector3([0.0, 4.0, 10.0]);
    gl.uniform3fv(uLightPosition, lightPosition.elements);
    gl.uniform3f(uAmbientColor, 0.1, 0.1, 0.1);
    
    // get matrix uniforms
    var uModelMatrix = gl.getUniformLocation(gl.program, "uModelMatrix");
    var uViewMatrix = gl.getUniformLocation(gl.program, "uViewMatrix");
    var uProjectionMatrix = gl.getUniformLocation(gl.program, "uProjectionMatrix");
    var uNormalMatrix = gl.getUniformLocation(gl.program, "uNormalMatrix");
    if (uModelMatrix < 0 ||
        uViewMatrix < 0 ||
        uProjectionMatrix < 0 ||
        uNormalMatrix < 0) {
        console.log("Failed to get matrix uniforms");
        return false;
    }
    
    // calculate projection (perspective) matrix
    var projectionMatrix = new Matrix4();
    var fov = 50; // field of view angle
    var aspect = canvas.width / canvas.height; // aspect ratio
    var near = 1; // near clip distance
    var far = 100; // far clip distance
    projectionMatrix.setPerspective(fov, aspect, near, far);
    
    // calculate the view matrix
    var viewMatrix = new Matrix4();
    viewMatrix.setLookAt(20.0,  // eye position x
                         10.0,  // eye position y
                         30.0,  // eye position z
                         0,     // lookat position x
                         0,     // lookat position y
                         0,     // lookat position z
                         0,     // up x
                         1,     // up y
                         0);    // up z
    
    // calcualate the model matrix
    var modelMatrix = new Matrix4();
    
    // calculate the normal matrix
    var normalMatrix = new Matrix4();
    
    // sends above matrices to the shader
    function updateUniforms() {
        gl.uniformMatrix4fv(uModelMatrix, false, modelMatrix.elements);
        gl.uniformMatrix4fv(uViewMatrix, false, viewMatrix.elements);
        gl.uniformMatrix4fv(uProjectionMatrix, false, projectionMatrix.elements);
        gl.uniformMatrix4fv(uNormalMatrix, false, normalMatrix.elements);
    }
    
    // for saving and restoring the current parent relative model matrix
    var matrixStack = [];
    function pushMatrix(matrix) {
        var m2 = new Matrix4(matrix);
        matrixStack.push(m2);
    }
    function popMatrix() {
        return matrixStack.pop();
    }
    
    // draws one of the specified global object buffers
    function drawSegment(buffer) {
        
        // bind the current buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.vertexAttribPointer(aPosition, buffer.num, buffer.type, false, 0, 0);
        gl.enableVertexAttribArray(aPosition);
        
        // update normal matrix based on current model matrix
        normalMatrix.setInverseOf(modelMatrix);
        normalMatrix.transpose();
        updateUniforms();
        
        // draw
        gl.drawElements(gl.TRIANGLES, n, gl.UNSIGNED_BYTE, 0);
    }
    
    const ANGLE_STEP = 3.0;
    var arm1Angle = 90.0;
    var joint1Angle = 45.0; // forearm angle
    var joint2Angle = 0.0; // hand angle
    var joint3Angle = 0.0; // fingers angle
    // all opengl drawing done in the main loop
    function draw() {
        
        // draw a 'base' square for the arm to set on
        const baseHeight = 2.0;
        modelMatrix.setTranslate(0.0, -12.0, 0.0);
        //drawBox(10.0, baseHeight, 10.0); // width, depth = 10.0
        drawSegment(baseBuffer);
        
        // Arm1 (bottom/base arm)
        const arm1Length = 10.0;
        modelMatrix.translate(0.0, baseHeight, 0.0); // translate relative to parent base above
        modelMatrix.rotate(arm1Angle, 0.0, 1.0, 0.0); // rotate y axis
        drawSegment(arm1Buffer);
        
        // Arm2 (top jointed arm)
        const arm2Length = 10.0;
        modelMatrix.translate(0.0, arm1Length, 0.0); // move to joint 1
        modelMatrix.rotate(joint1Angle, 0.0, 0.0, 1.0); // about z axis
        drawSegment(arm2Buffer);
        
        // Palm
        const palmLength = 2.0;
        modelMatrix.translate(0.0, arm2Length, 0.0); // move to top of arm2
        modelMatrix.rotate(joint2Angle, 0.0, 1.0, 0.0); // rotate about y axis
        drawSegment(palmBuffer);
        
        // move to center of the tip of the palm
        modelMatrix.translate(0.0, palmLength, 0.0);
        
        // finger 1 and finger 2 are siblings, so we need to save the current
        // hierarchy model transformation
        pushMatrix(modelMatrix);
            modelMatrix.translate(0.0, 0.0, 2.0);
            modelMatrix.rotate(joint3Angle, 1.0, 0.0, 0.0); // x axis rotation
            drawSegment(fingerBuffer);
        modelMatrix = popMatrix();
        
        // finger 2
        modelMatrix.translate(0.0, 0.0, -2.0);
        modelMatrix.rotate(-joint3Angle, 1.0, 0.0, 0.0); // x axis rotation
        drawSegment(fingerBuffer);
    }
    
    // register key presses for rotation
    document.onkeydown = function(eventObj) {
        switch (eventObj.keyCode) {
        case 38: // up arrow key -> positive rotation of joint1
            if (joint1Angle < 135.0) joint1Angle += ANGLE_STEP;
            break;
        case 40: // down arrow key -> negative rotation of joint1
            if (joint1Angle > -135.0) joint1Angle -= ANGLE_STEP;
            break;
        case 37: // left arrow key -> negative rotation of arm1 (y axis)
            arm1Angle = (arm1Angle - ANGLE_STEP) % 360.0;
            break;
        case 39: // right arrow key -> positive rotation of arm1 (y axis)
            arm1Angle = (arm1Angle + ANGLE_STEP) % 360.0;
            break;
        case 90: // z key -> position rotation of joint 2
            joint2Angle = (joint2Angle + ANGLE_STEP) % 360.0;
            break;
        case 88: // x key -> negative rotation of joint 2
            joint2Angle = (joint2Angle - ANGLE_STEP) % 360.0;
            break;
        case 86: // v key -> positive rotation of joint 3
            if (joint3Angle < 60.0) joint3Angle += ANGLE_STEP;
            break;
        case 67: // c key -> negative rotation of joint 3
            if (joint3Angle > -60.0) joint3Angle -= ANGLE_STEP;
            break;
        default:
            break;
        }
    };
    
    // continuously updates the screen
    function mainLoop() {
        // specify the color to clear the canvas with
        gl.clearColor(0.3, 0.0, 0.3, 1.0);
        
        // clear the canvas
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    
        // draw objects
        draw();
        
        // request the next frame
        requestAnimationFrame(mainLoop);
    }
    // initial loop call
    mainLoop();
}

// creates and stores 3 points in a vertex buffer, returning the number
// of vertices in the buffer
function initVertexBuffers(gl) {
    
    // separate buffers for each object
    var vertices_base = new Float32Array([ // Base(10x2x10)
     5.0, 2.0, 5.0, -5.0, 2.0, 5.0, -5.0, 0.0, 5.0,  5.0, 0.0, 5.0, // v0-v1-v2-v3 front
     5.0, 2.0, 5.0,  5.0, 0.0, 5.0,  5.0, 0.0,-5.0,  5.0, 2.0,-5.0, // v0-v3-v4-v5 right
     5.0, 2.0, 5.0,  5.0, 2.0,-5.0, -5.0, 2.0,-5.0, -5.0, 2.0, 5.0, // v0-v5-v6-v1 up
    -5.0, 2.0, 5.0, -5.0, 2.0,-5.0, -5.0, 0.0,-5.0, -5.0, 0.0, 5.0, // v1-v6-v7-v2 left
    -5.0, 0.0,-5.0,  5.0, 0.0,-5.0,  5.0, 0.0, 5.0, -5.0, 0.0, 5.0, // v7-v4-v3-v2 down
     5.0, 0.0,-5.0, -5.0, 0.0,-5.0, -5.0, 2.0,-5.0,  5.0, 2.0,-5.0  // v4-v7-v6-v5 back
  ]);
  
    var vertices_arm1 = new Float32Array([  // Arm1(3x10x3)
     1.5, 10.0, 1.5, -1.5, 10.0, 1.5, -1.5,  0.0, 1.5,  1.5,  0.0, 1.5, // v0-v1-v2-v3 front
     1.5, 10.0, 1.5,  1.5,  0.0, 1.5,  1.5,  0.0,-1.5,  1.5, 10.0,-1.5, // v0-v3-v4-v5 right
     1.5, 10.0, 1.5,  1.5, 10.0,-1.5, -1.5, 10.0,-1.5, -1.5, 10.0, 1.5, // v0-v5-v6-v1 up
    -1.5, 10.0, 1.5, -1.5, 10.0,-1.5, -1.5,  0.0,-1.5, -1.5,  0.0, 1.5, // v1-v6-v7-v2 left
    -1.5,  0.0,-1.5,  1.5,  0.0,-1.5,  1.5,  0.0, 1.5, -1.5,  0.0, 1.5, // v7-v4-v3-v2 down
     1.5,  0.0,-1.5, -1.5,  0.0,-1.5, -1.5, 10.0,-1.5,  1.5, 10.0,-1.5  // v4-v7-v6-v5 back
  ]);

  var vertices_arm2 = new Float32Array([  // Arm2(4x10x4)
     2.0, 10.0, 2.0, -2.0, 10.0, 2.0, -2.0,  0.0, 2.0,  2.0,  0.0, 2.0, // v0-v1-v2-v3 front
     2.0, 10.0, 2.0,  2.0,  0.0, 2.0,  2.0,  0.0,-2.0,  2.0, 10.0,-2.0, // v0-v3-v4-v5 right
     2.0, 10.0, 2.0,  2.0, 10.0,-2.0, -2.0, 10.0,-2.0, -2.0, 10.0, 2.0, // v0-v5-v6-v1 up
    -2.0, 10.0, 2.0, -2.0, 10.0,-2.0, -2.0,  0.0,-2.0, -2.0,  0.0, 2.0, // v1-v6-v7-v2 left
    -2.0,  0.0,-2.0,  2.0,  0.0,-2.0,  2.0,  0.0, 2.0, -2.0,  0.0, 2.0, // v7-v4-v3-v2 down
     2.0,  0.0,-2.0, -2.0,  0.0,-2.0, -2.0, 10.0,-2.0,  2.0, 10.0,-2.0  // v4-v7-v6-v5 back
  ]);

  var vertices_palm = new Float32Array([  // Palm(2x2x6)
     1.0, 2.0, 3.0, -1.0, 2.0, 3.0, -1.0, 0.0, 3.0,  1.0, 0.0, 3.0, // v0-v1-v2-v3 front
     1.0, 2.0, 3.0,  1.0, 0.0, 3.0,  1.0, 0.0,-3.0,  1.0, 2.0,-3.0, // v0-v3-v4-v5 right
     1.0, 2.0, 3.0,  1.0, 2.0,-3.0, -1.0, 2.0,-3.0, -1.0, 2.0, 3.0, // v0-v5-v6-v1 up
    -1.0, 2.0, 3.0, -1.0, 2.0,-3.0, -1.0, 0.0,-3.0, -1.0, 0.0, 3.0, // v1-v6-v7-v2 left
    -1.0, 0.0,-3.0,  1.0, 0.0,-3.0,  1.0, 0.0, 3.0, -1.0, 0.0, 3.0, // v7-v4-v3-v2 down
     1.0, 0.0,-3.0, -1.0, 0.0,-3.0, -1.0, 2.0,-3.0,  1.0, 2.0,-3.0  // v4-v7-v6-v5 back
  ]);

  var vertices_finger = new Float32Array([  // Fingers(1x2x1)
     0.5, 2.0, 0.5, -0.5, 2.0, 0.5, -0.5, 0.0, 0.5,  0.5, 0.0, 0.5, // v0-v1-v2-v3 front
     0.5, 2.0, 0.5,  0.5, 0.0, 0.5,  0.5, 0.0,-0.5,  0.5, 2.0,-0.5, // v0-v3-v4-v5 right
     0.5, 2.0, 0.5,  0.5, 2.0,-0.5, -0.5, 2.0,-0.5, -0.5, 2.0, 0.5, // v0-v5-v6-v1 up
    -0.5, 2.0, 0.5, -0.5, 2.0,-0.5, -0.5, 0.0,-0.5, -0.5, 0.0, 0.5, // v1-v6-v7-v2 left
    -0.5, 0.0,-0.5,  0.5, 0.0,-0.5,  0.5, 0.0, 0.5, -0.5, 0.0, 0.5, // v7-v4-v3-v2 down
     0.5, 0.0,-0.5, -0.5, 0.0,-0.5, -0.5, 2.0,-0.5,  0.5, 2.0,-0.5  // v4-v7-v6-v5 back
  ]);
    
    // the colors to store in the second buffer
    var colors = new Float32Array([
        1, 0, 0,   1, 0, 0,   1, 0, 0,  1, 0, 0,     // v0-v1-v2-v3 front
        1, 0, 0,   1, 0, 0,   1, 0, 0,  1, 0, 0,     // v0-v3-v4-v5 right
        1, 0, 0,   1, 0, 0,   1, 0, 0,  1, 0, 0,     // v0-v5-v6-v1 up
        1, 0, 0,   1, 0, 0,   1, 0, 0,  1, 0, 0,     // v1-v6-v7-v2 left
        1, 0, 0,   1, 0, 0,   1, 0, 0,  1, 0, 0,     // v7-v4-v3-v2 down
        1, 0, 0,   1, 0, 0,   1, 0, 0,  1, 0, 0   // v4-v7-v6-v5 back
    ]);
    
    // normals used for lighting calculation
    // these are the same for each of the above objects since they are all
    // scaled cubes
    var normals = new Float32Array([
        0.0, 0.0, 1.0,   0.0, 0.0, 1.0,   0.0, 0.0, 1.0,   0.0, 0.0, 1.0,  // v0-v1-v2-v3 front
        1.0, 0.0, 0.0,   1.0, 0.0, 0.0,   1.0, 0.0, 0.0,   1.0, 0.0, 0.0,  // v0-v3-v4-v5 right
        0.0, 1.0, 0.0,   0.0, 1.0, 0.0,   0.0, 1.0, 0.0,   0.0, 1.0, 0.0,  // v0-v5-v6-v1 up
       -1.0, 0.0, 0.0,  -1.0, 0.0, 0.0,  -1.0, 0.0, 0.0,  -1.0, 0.0, 0.0,  // v1-v6-v7-v2 left
        0.0,-1.0, 0.0,   0.0,-1.0, 0.0,   0.0,-1.0, 0.0,   0.0,-1.0, 0.0,  // v7-v4-v3-v2 down
        0.0, 0.0,-1.0,   0.0, 0.0,-1.0,   0.0, 0.0,-1.0,   0.0, 0.0,-1.0   // v4-v7-v6-v5 back
    ]);
    
    // indices of the above vertices
    // important - use Uint16Array if there are more than 256 vertices
    var indices = new Uint8Array([        
     0, 1, 2,   0, 2, 3,    // front
     4, 5, 6,   4, 6, 7,    // right
     8, 9,10,   8,10,11,    // up
    12,13,14,  12,14,15,    // left
    16,17,18,  16,18,19,    // down
    20,21,22,  20,22,23     // back
    ]);
    
    var n = 12*3; // 12 triangles times 3 points per vertex
    
    // store vertex coordinates in the buffers for each arm object
    baseBuffer = initArrayBufferForLaterUse(gl, vertices_base, 3, gl.FLOAT);
    arm1Buffer = initArrayBufferForLaterUse(gl, vertices_arm1, 3, gl.FLOAT);
    arm2Buffer = initArrayBufferForLaterUse(gl, vertices_arm2, 3, gl.FLOAT);
    palmBuffer = initArrayBufferForLaterUse(gl, vertices_palm, 3, gl.FLOAT);
    fingerBuffer = initArrayBufferForLaterUse(gl, vertices_finger, 3, gl.FLOAT);
    if (!baseBuffer || !arm1Buffer || 
        !arm2Buffer || !palmBuffer || !fingerBuffer) {
        console.log("failed to create object buffers");
        return -1;
    }
    // save the shader attrib vertex positions location for later
    aPosition = gl.getAttribLocation(gl.program, "aPosition");
    if (aPosition < 0) {
        console.log("Failed to get aPosition attrib");
        return -1;
    }
    
    // create the buffer object
    var colorBuffer = gl.createBuffer();
    var normalBuffer = gl.createBuffer();
    var indexBuffer = gl.createBuffer();
    if (!indexBuffer || !colorBuffer || !normalBuffer) {
        console.log("Failed to create vertex or index buffer obj");
        return -1;
    }
    
    const floatSize = vertices_base.BYTES_PER_ELEMENT; // each float is 4 bytes
    
    // we are now referring to the color buffer
    gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);
    
    // Get vertex attribute
    var aColor = gl.getAttribLocation(gl.program, "aColor");
    if (aColor < 0) {
        console.log("Failed to get aColor attribute");
        return -1;
    }
    
    // tell opengl about the data we just sent it
    gl.vertexAttribPointer(aColor,   // the attribute location
                            3,          // number of points per element (r,g,b)
                            gl.FLOAT,   // vertex data type
                            false,      // does the data need normalization?
                            3 * floatSize,   // how many bytes to move to the next vertex
                            0);  // first vertex entry offset
    // give opengl the OK to use these properties for this attribute
    gl.enableVertexAttribArray(aColor);
    
    // bind the buffer object that we are currently referring to
    gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
    // send data to the buffer
    gl.bufferData(gl.ARRAY_BUFFER, normals, gl.STATIC_DRAW);
    
    // Get vertex attribute
    var aNormal = gl.getAttribLocation(gl.program, "aNormal");
    if (aNormal < 0) {
        console.log("Failed to get aNormals attribute");
        return -1;
    }
    
    // tell opengl about the data we just sent it
    gl.vertexAttribPointer(aNormal,   // the attribute location
                            3,          // number of points per vertex (x,y,z)
                            gl.FLOAT,   // vertex data type
                            false,      // does the data need normalization?
                            3 * floatSize, // how many bytes to move to the next vertex (0 for default)
                            0);         // first vertex entry offset
    // give opengl the OK to use these properties for this attribute
    gl.enableVertexAttribArray(aNormal);
    
    // send elements (indices) data to the index buffer
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
    
    // give back the number of vertices in the buffer
    return n;
}

// creates a gl buffer, giving it data and saving the number and type of each vertex
function initArrayBufferForLaterUse(gl, data, num, type) {

    // init the GL buffer obj
    var buffer = gl.createBuffer();
    if (!buffer) {
        console.log("failed to create buffer object");
        return null;
    }
    
    // give the data to the buffer
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);
    
    // save info for later
    buffer.num = num;
    buffer.type = type;
    
    return buffer;
}

</script>
</body>
</html>
