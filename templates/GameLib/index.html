<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>BJ's Website</title>
    <link rel="stylesheet" type="text/css" href="../../site.css"/>
</head>
<body style="min-height:1000px;">
<h1>GameLib</h1>

<p>
Starting to combine my code for different platforms into a single library.
For now simply called <i>GameLib</i>. TBD a cooler, better sounding name :).
Originally this repo had PS2 and PSX code, now I'm redoing it as I have more
experience and worked with other platforms. Plus, multiplatform support including
PSX is hard because of the PSX needing to do everything in fixed-point.
</p>

<p>
The code is here:
<a href="https://bitbucket.org/williamblair/workspace/projects/GAM">https://bitbucket.org/williamblair/workspace/projects/GAM</a>,
where the GameLib repo contains the library code, and iqmanimpc for now is the test applicaton.
Also uses my GameMath library as a submodule for GameLib:
<a href="https://bitbucket.org/williamblair/gamemath/src/master/">https://bitbucket.org/williamblair/gamemath/src/master/</a>
</p>

<h3>04/23/2022</h3>
<p>Base PC and Wii implementations working together. Includes a third-person controlled
animated IQM model and tiled floor:</p>

<img src="images/iqmanim_04_23_2022.png" width="400px"/>

<p>The PC implementation uses Visual Studio 2019 for Windows.
The libraries used are SDL2 and GLEW, so it *should* work
on Linux as well. Still need to make a Makefile for linux. For
windows, compile.bat is used with the VS developer command prompt
to call cl.exe with the required args. A preprocessor define
PC_BUILD is used by GameMath and some initialization/file loading.</p>

<p>The wii implementation uses Makefile.wii with devkitpro. The main
difference between the Wii and PC implemenations currently is texture
loading on the wii uses textures baked into the code, so the loading
functions are different. TODO is figure out how to load textures for
wii from a file. The preprocessor define WII_BUILD is used in this
case. The differences between main.cpp for the PC and Wii are:</p>

<pre><code>#ifdef PC_BUILD
using namespace GameLib::PC;
#undef main
#endif

#ifdef WII_BUILD
// IQM texture
#include "Gina.h"
#include "Gina_tpl.h"
// Ground texture
#include "grass.h"
#include "grass_tpl.h"
using namespace GameLib::Wii;
#endif

...

#ifdef PC_BUILD
    if (!gRender.Init(800, 600, "Hello World")) { return 1; }
    if (!gInput.Init()) { return 1; }
    if (!gGrassTex.LoadFromTGA("assets/grass.tga")) { return 1; }
    if (!gIqm.Init("assets/gina.iqm")) { return 1; }
    if (!gIqmTex.LoadFromTGA("assets/gina.tga")) { return 1; }
#endif
#ifdef WII_BUILD
    if (!gRender.Init(640, 480, "Hello World")) { return 1; }
    if (!gInput.Init()) { return 1; }
    if (!gGrassTex.Init(grass_tpl, grass_tpl_size, grass)) { return 1; }
    if (!gIqm.Init("sd:/gina.iqm")) { return 1; }
    if (!gIqmTex.Init(Gina_tpl, Gina_tpl_size, gina)) { return 1; }
#endif
</code></pre>

<p>TODO is to retest on Wii hardware to make sure it still works. Up next is the
PS3 base implementation. Hopefully after that PS2 support as well (maybe...)</p>

<h3>04/24/2022</h3>

<p>Started PS3 implementation. Confirmed a simple triangle drawing works.
Basically all there, except there's still a camera
issue between tiny3d using +z=forwards 0..65535 and GameMath using +z=backwards.
I think the main issue currently is the tiny3d vertex shader:</p>
<pre><code>v = mul(inputvertex.vertex, WorldMatrix);
outputvertex.vertex    = mul(v,ProjMatrix);
outputvertex.vertex.z *= outputvertex.vertex.w;
</code></pre>

<p>This last line (z*w) I believe is causing the GameMath matrix implementations
to be incompatible. I've been trying to figure out if I can remove that line and
recompile ther vertex shader for tiny3d. It seems to be baked into the code via
the vpcomp utility, which is no longer used by PSL1GHT and has been replaced by cgcomp.
Cgcomp seems to output a different format than vpcomp. I was able to compile vpcomp from
an older commit of PSL1GHT, but it gives errors when trying to compile the vertex shader.
The first error was "pow" being an unsupported function</p>

<img src="images/vpcomp_error1_04_24_2022.png" width="600px"/>

<p>After commenting out the line that uses pow, a error related to a register
is given:</p>

<img src="images/vpcomp_error2_04_24_2022.png" width="600px"/>

<p>I'm guessing maybe the version of nvidia-cg-toolkit (libCg)
is newer now compared to ~2011 and is causing the issue? However
older versions from the nvidia website are unavailable (only 3.31
is available). The only other thing I can try maybe is modifying
the tiny3d source code to account for the z*w vertex shader line
when sending vertices/matrices to the shader. Otherwise I might
try just using PSL1GHT again without tiny3d and make the code more similar to how
tiny3d works (allocating a single block of RSX memory for vertices)</p>

<h3>04/28/2022</h3>

<p>Switched from tiny3d to plain PSL1GHT ps3 impl. Had two issues:
one, there seems to be a bug somewhere in the ps3 implementation of GameMath, as switching
from the ps3 impl to the plain c++ impl fixed incorrect rendering initially. I haven't
looked into the issue yet. I thought I had ran into this and already fixed it earlier,
but maybe not.</p>

<p>The second was that some vertices would freak out and render incorrectly on my actual
PS3 hardware but not on rpcs3. I've seen this happen before on my previous PS3/PSL1GHT programs
so I wasn't super surprised that it happened. After playing around with different options related
to vertex clipping in the renderer code, the following seem to have fixed the issue/render correctly
without freakouts:</p>
<pre><code>// don't call this function:
//rsxSetZMinMaxControl(context, 0, 1, 1);

// do call this function:
for (i=0; i&lt;8; i++) {
    rsxSetViewportClip(context, i, display_width, display_height);
}

// don't call this function:
//rsxSetUserClipPlaneControl(context,GCM_USER_CLIP_PLANE_DISABLE,GCM_USER_CLIP_PLANE_DISABLE,...)
</code></pre>
<p>Which were functions I saw used in different examples code. Also, as a side note, I was able
to use OpenGL-style glsl shaders following this post by user Crystal:
<a href="https://www.psx-place.com/threads/how-to-use-glsl-shaders-inside-psl1ght-rsx-projects.34239/">link</a>.
The glsl and regular PSL1GHT equivalent versions of the shader I'm using so far are:
</p>

<pre><code>//glsl vertex/fragment shader
#version 130
in vec3 aPos;
in vec3 aColor;
out vec4 fragColor;
uniform mat4 uMvpMatrix;
void main(void)
{
    gl_Position = uMvpMatrix * vec4(aPos, 1.0);
    fragColor = vec4(aColor, 1.0);
}
---
#version 130
out vec4 FragColor;
in vec4 fragColor;
void main(void)
{
    FragColor = fragColor;
}

// PSL1GHT version (hlsl/directX? not sure)
void main
(
    float3 aPos : POSITION,
    float3 aColor : COLOR,
    uniform float4x4 uMvpMatrix,
    out float4 ePosition : POSITION,
    out float3 oColor : COLOR
)
{
    float4 v;
    v = mul(float4(aPos, 1.0f), uMvpMatrix);
    ePosition = v;
    oColor = aColor;
}
---
void main
(
    float3 color : COLOR,
    out float4 oColor
)
{
    float4 testColor = float4(color, 1.0);
    oColor = testColor;
}
</code></pre>

<p>Currently the PSL1GHT version is used and is what I tested on my actual PS3. Below
shows before fixing the vertex freakout issue and after. Next TODO for PS3 is to add back in
textures and IQM model support.</p>

<video controls width="500px">
    <source src="./images/vertex_clip_issue_04_28_2022.webm" type="video/webm"/>
</video>
<br/>
<video controls width="500px">
    <source src="./images/vertex_clip_fixed_04_28_2022.webm" type="video/webm"/>
</video>

<h3>04/29/2022</h3>
<p>Got PS3 iqm anim working and re-verified Wii working on hardware. Also made some
changes on the Wii implementation to get the hello world simple triangle drawing
working. The issue for Wii was the Renderer::Clear() call was setting up to use
a texture, which the simple triangle drawing wasn't using.</p>
<p>For the rest of the ps3 impl for iqm animation, I found again there's an issue
with the PS3 GameMath impl. When using the PS3 impl, the IQM model wasn't shown
onscreen, but the tile floor rendered fine/as expected. That makes me think there's
something wrong with the Quaternion ps3 impl, as the tile floor doesn't use them.
For now though, switching it to use the plain cpp implementation of GameMath works
fine.</p>
<p>The shader I added for textured rendering on ps3 looks like:</p>
<pre><code>void main
(
    float3 aPos : POSITION,
    float2 aTexCoord : TEXCOORD0,

    uniform float4x4 uMvpMatrix,

    out float4 ePosition : POSITION,
    out float2 oTexCoord : TEXCOORD0
)
{
    float4 v;

    v = mul(float4(aPos, 1.0f), uMvpMatrix);
    ePosition = v;

    oTexCoord = aTexCoord;
}
---
void main
(
    float2 texCoord : TEXCOORD0,

    uniform sampler2D uTexture,

    out float4 oColor
)
{
    float4 testColor = tex2D(uTexture, texCoord);
    oColor = testColor;
}</code></pre>

<p>Yesterday I got the pspdev environment set up, so I can try and create a PSP
implementation as well. There seems to be a larger/more active PSP community
based on my brief searching and the toolchain seems to be very modern/actively
maintained. The example I tried yesterday uses CMake and the compiler for pspdev
is gcc 11.2, which is the latest I think. Because of this I'm (knock on wood)
guessing the PSP implementation should be fairly straightforward.</p>

<h3>04/30/2022</h3>

<p>Started the psp implementation; added enough to get the gamelibhellworld triangle
drawing and camera movement working. Most of the information/psp code came from
<a href="https://web.archive.org/web/20090124081552/http://ghoti.nl/PSPtutorials.php">
https://web.archive.org/web/20090124081552/http://ghoti.nl/PSPtutorials.php
</a> and the corresponding code at
<a href="https://github.com/PSP-Archive/3D-PSP-Tutorials">
https://github.com/PSP-Archive/3D-PSP-Tutorials
</a>. Graphics using pspsdk kind of seems to be a hybrid between old/fixed function
and modern OpenGL. There aren't shaders (that I've seen), but you don't call a function
to specify each vertex point; all vertices are drawn in a single call. The matrix system
is like older OpenGL though with an internal matrix stack. Luckily, the matrix format
directly matches the GameMath cpp implementation. We can directly feed psp sdk our
GameMath matrices via:</p>
<pre><code>// set projection matrix
sceGumMatrixMode(GU_PROJECTION);
sceGumLoadIdentity();
sceGumLoadMatrix((const ScePspFMatrix4*)&amp;mProjMat.r0c0);
// set view matrix
sceGumMatrixMode(GU_VIEW);
sceGumLoadMatrix((const ScePspFMatrix4*)&amp;viewMat.r0c0);
// set model matrix
sceGumMatrixMode(GU_MODEL);
sceGumLoadMatrix((const ScePspFMatrix4*)&amp;modelMat.r0c0);
</code></pre>

<p>The direct cast works as both structures are 16 floats in column major order.
One difference I noticed is the Sce matrices are 16byte aligned.</p>

<p>Another interesting difference for the psp implementation is the required
format and order of vertex attributes. In modern OpenGL you specify each attribute
of the vertex buffer/array. For pspsdk, there is a fixed combinations of formats and
order of attributesyou can use. From the pspsdk doxygen documenation
<a href="https://pspdev.github.io/pspsdk/group__GU.html#ga7ee605d6909a72f989cae1cc4bf6264f">here</a>,
the required order (if included) is:
</p>
<pre>[vertices(1-8)] [weights (0-8)] [texture uv] [color] [normal] [vertex]</pre>
<p>So each attribute isn't required in the vertices, if an attribute is included, it
must be in this order in the data you send it.
You specify which attributes are included as an argument to <i>sceGuDrawArray()</i>.
For just having color and position attributes, the draw call looks like:</p>
<pre><code>sceGumDrawArray(
    GU_TRIANGLES,
    GU_COLOR_8888 | GU_VERTEX_32BITF | GU_TRANSFORM_3D,
    vb.mNumVertices,
    0,
    vb.mPosColorVertices
);
</code></pre>

<p>Where vb.mPosColorVertices is an array internally stored in my VertexBuffer class
where each element has the following format:</p>
<pre><code>struct PosColorVertex {
    unsigned char r, g, b, a;
    float x, y, z;
};
</code></pre>
<p>Upon VertexBuffer initialization, the input vertices are stored in mPosColorVertices
in this format, as the input vertices are x,y,z, r,g,b and need to be converted.</p>

<p>I haven't tried running the code on hardware yet - just on PPSSPP. I dusted off my PSP yesterday and
confirmed it turns on, but the battery seems to be shot and it's not recognizing the memory
stick. I ordered a new battery and memory stick which should get here sometime next week probably.
Then I'll have to go through the "jailbreaking" process again, which I don't remember how to do...</p>

<h3>05/04/2022</h3>
<p>PSP iqm anim impl working (again, at least in PPSSPP). Got the new PSP
battery in today but still waiting on the memory stick. I disabled
culling because it seems the triangle order for the IQM is backwards,
causing the front to be culled instead of the back:</p>
<img src="images/psp_culling_05_2_2022.jpg" width="500px"/><br/>

<p>Also, a TODO is use indexed rendering. I've been putting it off
because it seems that pspsdk only supports 8 and 16bit indices; for
all other implementations so far I've been using 32bit. Not sure if
restricting the size to 16bits would cause an issue yet or not. To
get around it, I've been having the VertexBuffer class upon initialization/
vertices update to convert from indexed to non-indexed vertices.</p>
<p>I ran into an issue where it seems the constructor for the
ThirdPersonPlayer class wasn't being ran properly; I had to manually
set the default settings in main() instead:</p>
<pre><code>gPlayer.SetModel(&gIqm);
gPlayer.SetModelScale(GameMath::Vec3(0.1f, 0.1f, 0.1f));
gPlayer.SetTexture(&gIqmTex);
gPlayer.GetCamera().SetDistance(15.0f);
gPlayer.SetDrawYawOffset(180.0f);
gPlayer.SetDrawPitchOffset(-90.0f);
gPlayer.Update(0.0f);
</code></pre>
<p>For the curren tresult, triangles near the edge of the view frustum seem to be
getting cut off prematurely; I think this is mentioned in the above
Ghoti tutorials to addressed later on.</p>
<video controls style="width:400px">
    <source src="./images/psp_floorclipping_05_04_2022.webm" type="video/webm"/>
</video>

<p>
<a href="../../index.html">&lt;-- Back to Home</a>
</p>

</body>
</html>

