<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>BJ's Website</title>
  <link rel="stylesheet" type="text/css" href="../../site.css"/>
  
</head>
<body>

<div id="bodyDiv">

<div id="contentDiv">

<h1>PS3 Programming Log</h1>
<img alt="PS2 Logo" style="float:right; margin:5px;" src="https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Flogonoid.com%2Fimages%2Fplaystation-3-logo.png&f=1&nofb=1" width="400px"/>

<p>My working log for learning programming for the Playstation 3. Inspired
by <a href="https://research.ncl.ac.uk/game/mastersdegree/">Newcastle University's
Computer Game Engineering Content</a> where they have a few sections on PS3 programming.
Unfortunately, they seem to use the official SONY PS3 Devkit, which of course we don't
have access too. There is however an open source ps3sdk we can use:
<a href="https://github.com/ps3dev">https://github.com/ps3dev</a>. I've followed so far
the first introduction section from the Newcastle content and it seems like a good resource;
the only drawback is it's Windows and Visual Studio oriented. (Another future project TODO -
convert their example code to SDL/GLEW for Linux support!)</p>

<p>For PS3 my current goal is
to get MD5 skeletal animation working
<a href="https://research.ncl.ac.uk/game/mastersdegree/graphicsforgames/skeletalanimation/">
from the NewCastle tutorial</a>, and possibly 
the GLTF skeletal animation from <a href="https://www.amazon.com/Hands-Game-Animation-Programming-implementation/dp/1800208081">
Hands-On C++ Game Animation Programming</a>. Also, it'd be cool to get
<a href="https://github.com/gzorin/RSXGL">RSXGL</a> working, which is an OpenGL 3.1
implementation, but I haven't had any luck so far.</p>

<p>The source code is currently here: <a href="https://bitbucket.org/williamblair/ps3devprogs">https://bitbucket.org/williamblair/ps3devprogs</a></p>

<h3>05/15/2021</h3>

<p>Looking through the
<a href="https://github.com/ps3dev/PSL1GHT/tree/master/samples/graphics/rsxtest">
psl1ght graphics example</a>. Seems actually pretty similar to OpenGL: we have shaders,
buffer attributes, texture formats, etc...
</p>
<p>The shaders are NOT compiled and loaded at runtime like in OpenGL; instead they are
pre-compiled at the same time as the main program and stored as byte arrays and included
as C headers.</p>
<p>The shader language seems pretty similar to GLSL except programs take in
a bunch of function arguments intead of global vars:</p>
<pre><code>void main
(
    float3 vertexPosition : POSITION,
    float3 vertexNormal : NORMAL,
    float2 vertexTexcoord : TEXCOORD0,
    
    uniform float4x4 projMatrix,
    uniform float4x4 modelViewMatrix,
    
    out float4 ePosition : POSITION,
    out float4 oPosition : TEXCOORD0,
    out float3 oNormal : TEXCOORD1,
    out float2 oTexcoord : TEXCOORD2
)
{
    ePosition = mul(mul(projMatrix,modelViewMatrix),float4(vertexPosition,1.0f));
    
    oPosition = float4(vertexPosition,1.0f);
    oNormal = vertexNormal;
    oTexcoord = vertexTexcoord;
}
</code></pre>

<p>Vertex buffer data seems to be stored on GPU memory but accessible from the CPU.
The memory is allocated via rsxMemalign() and then vertex data is copied into it.
There is an 'offset' associated with this allocation used as arguments to other functions;
I'm assuming this is like the address of the memory block within GPU memory.</p>
<pre><code>m_meshBuffer-&gt;vertices = (S3DVertex*)rsxMemalign(128,m_meshBuffer-&gt;cnt_vertices*sizeof(S3DVertex));
...
m_meshBuffer-&gt;vertices[i] = S3DVertex(pos.getX(),pos.getY(),pos.getZ(),normal.getX(),normal.getY(),normal.getZ(),tu,static_cast<f32>(ay*RECIPROCAL_PI));
u32 offset = 0;    
rsxAddressToOffset( &amp;m_meshBuffer-&gt;vertices[0].pos, &amp;offset );
</code></pre>
<p>The S3DVertex and SBuffer classes are included with the psl1ght sample as custom objects (mesh.h), so we
don't have to use those if we don't want to.</p>
<p>As a side note, the main CPU is the PowerPC Processor Unit (PPU) and then there are 
eight SPUs to execute separate programs to run in parallel if desired (see 
<a href="https://mirrors.edge.kernel.org/pub/linux/kernel/people/geoff/cell/ps3-linux-docs/CellProgrammingTutorial/BasicsOfCellArchitecture.html">here</a>).
RSX stands for reality synthesizer and is the PS3 GPU (see <a href="https://www.psdevwiki.com/ps3/RSX">here</a>.)
</p>
<p>The compiled program results in a .elf file (similar to the PS2), but for the PS3 this
needs to be converted into a .self file which I think is an encrypted version of the .elf.
Using ps3load with the elf file didn't seem to work but using the .self file did. Conversion
to a .self is done automatically with the ps1light sample makefile.</p>

<p>I remorked the sample code to remove the lighting (to simplify things), then made the
following C++ classes:</p>
<ul>
<li>Shader</li>
<li>Texture</li>
<li>Entity
    <ul>
     <li>Sphere</li>
     <li>Torus</li>
     <li>Cube</li>
    </ul>
</li>
</ul>

<p>Rendering an entity then works the same as opengl, where you set shader
and vertex buffer attributes, then draw indexed arrays:</p>
<pre><code>g_Shader.Use();
g_Shader.SetVertexProgParam( "projMatrix", (float*)&amp;P );
g_Shader.SetVertexProgParam( "modelViewMatrix", (float*)&amp;modelViewMatrix );
...
g_Sphere.Render();
</code></pre>

<p>TODO is to make a rendering class, also have a single shader SetAttribute
function for both vertex shader and fragment shader attribs.
I also made a Logging namespace and macro which logs to both
TTY/stdout and the debug font sample to the screen:</p>
<pre><code>#define DBG_LOG(format, ...)                                            \
    sprintf( Log::dbgPrintStr, "%s:%d: ", __FILE__, __LINE__ );         \
    Log::len = strlen( Log::dbgPrintStr );                              \
    sprintf( &amp;Log::dbgPrintStr[ Log::len ], format, ##__VA_ARGS__ );    \
                                                                        \
    printf( Log::dbgPrintStr );                                         \
                                                                        \
    Log::dbgLogHistory.push_back( Log::dbgPrintStr );                   \
    if ( Log::dbgLogHistory.size() &gt; LOG_HISTORY_LEN ) {                \
        Log::dbgLogHistory.pop_front();                                 \
    }
</code></pre>

<p>I originally tried an inline function but that resulted in the function
not actually being able to be inlined, and thus the __FILE__ and __LINE__
preprocessor vars were not showing the desired call location, and instead were
all showing the same line and function for inside the log call. So I used a
macro instead.
For the DBG_LOG macro, an important note is you need the two ## in front
of __VA_ARGS__ in order to prevent errors when no extra args were provided to
the macro. This might be gcc specific.</p>
<p>The result of this rework can be seen running in the rpcs3 emulator, though
I've confirmed it runs on hardware too:</p>

<img src="images/basic_entity_5_15_2021.png" width="600px"/>

<h3>05/22/2021</h3>
<p>Added pad class for the controller. Basic psl1ght API usage for the pad
is as follows:</p>
<pre><code>ioPadInit(7); // Idk what 7 means, TODO - look this up
...
padInfo info;
padData data;
int padnumber = 0;
while (true)
{
    ioPadGetInfo( &amp;info );
    if ( info.status[ padnumber ] )
    {
        ioPadGetData( padnumber, &amp;data );
        bool crossPressed = (bool)data.BTN_CROSS;
    }
}
</code></pre>

The list of available info from padData, based on the generated doxygen
from the ps3toolchain build is below (I could probably upload the generated
doxygen here, it'd be easier than opening the html locally...):
<pre><code>typedef struct _pad_data
 {
     s32 len;                                
     union{
         u16 button[MAX_PAD_CODES];          
         struct {
             u16 zeroes;                     
             unsigned int : 8;               
             unsigned int seven : 4;         
             unsigned int halflen : 4;       
             unsigned int : 8;               
             /* Button information */
             /* 0: UP, 1: DOWN */
             unsigned int BTN_LEFT : 1;      
             unsigned int BTN_DOWN : 1;      
             unsigned int BTN_RIGHT : 1;     
             unsigned int BTN_UP : 1;        
             unsigned int BTN_START : 1;     
             unsigned int BTN_R3 : 1;        
             unsigned int BTN_L3 : 1;        
             unsigned int BTN_SELECT : 1;    
             unsigned int : 8;               
             unsigned int BTN_SQUARE : 1;    
             unsigned int BTN_CROSS : 1;     
             unsigned int BTN_CIRCLE : 1;    
             unsigned int BTN_TRIANGLE : 1;  
             unsigned int BTN_R1 : 1;        
             unsigned int BTN_L1 : 1;        
             unsigned int BTN_R2 : 1;        
             unsigned int BTN_L2 : 1;        
             /* Analog nub information */
             /* 0x0000 - 0x00FF */
             unsigned int ANA_R_H : 16;
             unsigned int ANA_R_V : 16;
             unsigned int ANA_L_H : 16;
             unsigned int ANA_L_V : 16;
 
             /* Pressure-sensitive information */
             /* 0x0000 - 0x00FF */
             unsigned int PRE_RIGHT : 16;
             unsigned int PRE_LEFT : 16;
             unsigned int PRE_UP : 16;
             unsigned int PRE_DOWN : 16;
             unsigned int PRE_TRIANGLE : 16;
             unsigned int PRE_CIRCLE : 16;
             unsigned int PRE_CROSS : 16;
             unsigned int PRE_SQUARE : 16;
             unsigned int PRE_L1 : 16;
             unsigned int PRE_R1 : 16;
             unsigned int PRE_L2 : 16;
             unsigned int PRE_R2 : 16;
 
             /* Sensor information */
             /* 0x0000 - 0x03FF */
             unsigned int SENSOR_X : 16;
             unsigned int SENSOR_Y : 16;
             unsigned int SENSOR_Z : 16;
             unsigned int SENSOR_G : 16;
 
             /* BD remote information */
             unsigned int BTN_BDLEN : 16;    
             unsigned int BTN_BDCODE : 16;   
             u8 reserved[76];
         };
     };
 } padData;
</code></pre>

Then for my pad class, I made the following test to check button click/press/
vibration (called "actuators")/analog sticks:

<pre><code>Pad pad;
...
pad.Init( 0 ); // controller 0
..
while (true)
{
    pad.Update();
    if ( pad.IsHeld( Pad::CROSS ) ) {
        goto done;
    }
    
    // large actuator
    static unsigned short algVal;
    algVal = pad.GetLeftAnalogY();
    static unsigned short prevAlgVal = algVal;
    if ( algVal != prevAlgVal )
    {
        if ( algVal &gt; prevAlgVal &amp;&amp; algVal - prevAlgVal &gt; 5 )
        {
            pad.SetLargeActuator( algVal );
        }
        else if ( algVal &lt; prevAlgVal &amp;&amp; prevAlgVal - algVal &gt; 5 )
        { 
            pad.SetLargeActuator( algVal );
        }
        DBG_LOG( "Alg X: %u", algVal );
    }
    prevAlgVal = algVal;

    // small actuator
    if ( pad.IsClicked( Pad::SQUARE ) )
    {
        static bool actVal = false;
        actVal = !actVal;
        pad.SetSmallActuator( actVal );
    }
    
    ...
}
</code></pre>

<p>Also created renderer class. Currently relies too heavily on rsxutil.h/cpp,
so a TODO is inspect those internals. Basic usage is as follows:</p>

<pre><code>Renderer renderer;
Entity entity;
renderer.Init();
while (1)
{
    renderer.BeginFrame();
    renderer.RenderEntity( entity );
    renderer.EndFrame();
}
</code></pre>

<p>RenderEntity() actually forwards the important drawing to the Entity
class; it sets render clip settings then just calls Entity::Render()</p>

<pre><code>void Renderer::RenderEntity( Entity&amp; entity )
{
    rsxSetUserClipPlaneControl(context,GCM_USER_CLIP_PLANE_DISABLE,
                                       GCM_USER_CLIP_PLANE_DISABLE,
                                       GCM_USER_CLIP_PLANE_DISABLE,
                                       GCM_USER_CLIP_PLANE_DISABLE,
                                       GCM_USER_CLIP_PLANE_DISABLE,
                                       GCM_USER_CLIP_PLANE_DISABLE);
    entity.Render();
}
</code></pre>

<p>To actually draw triangles, the process is quite OpenGL like:
you set vertex pointer attribs and then (in this case) draw indexed
triangles (code from Entity.cpp):</p>
<pre><code>rsxAddressToOffset( &amp;m_meshBuffer-&gt;vertices[0].pos, &amp;offset );
rsxBindVertexArrayAttrib( m_context,
                          GCM_VERTEX_ATTRIB_POS,
                          0,
                          offset,
                          sizeof( S3DVertex ),
                          3,
                          GCM_VERTEX_DATA_TYPE_F32,
                          GCM_LOCATION_RSX );

rsxAddressToOffset( &amp;m_meshBuffer-&gt;vertices[0].nrm, &amp;offset );
rsxBindVertexArrayAttrib( m_context,
                          GCM_VERTEX_ATTRIB_NORMAL,
                          0,
                          offset,
                          sizeof( S3DVertex ),
                          3,
                          GCM_VERTEX_DATA_TYPE_F32,
                          GCM_LOCATION_RSX );

rsxAddressToOffset( &amp;m_meshBuffer-&gt;vertices[0].u, &amp;offset );
rsxBindVertexArrayAttrib( m_context,
                          GCM_VERTEX_ATTRIB_TEX0,
                          0,
                          offset,
                          sizeof( S3DVertex ),
                          2,
                          GCM_VERTEX_DATA_TYPE_F32,
                          GCM_LOCATION_RSX );

rsxAddressToOffset( &amp;m_meshBuffer-&gt;indices[0], &amp;offset );
rsxDrawIndexArray( m_context,
                   GCM_TYPE_TRIANGLES,
                   offset,
                   m_meshBuffer-&gt;cnt_indices,
                   GCM_INDEX_TYPE_16B,
                   GCM_LOCATION_RSX );

</code></pre>

<p>Next, I tested file I/O. This is a luxury compared to PS2 and PS1 - there
is a PS3 OS which provides filesystem access for us! At first, I tried to
program a test file location relative to the SELF executable directory, but
the test.txt file failed to open. I added a DEFINE for the assets directory
instead so the absolute path was used:</p>

<pre><code>Makefile:
  ASSETS_DIR  :=  /dev_hdd0/rsxtest/game/assets
  TARGET      :=  game/rsxtest
  ...
  CFLAGS      =   -Wall -mcpu=cell $(MACHDEP) $(INCLUDE) -DASSETS_DIR=\"$(ASSETS_DIR)\"

Code:
 static void fileTest()
  {
      std::string line;
      std::ifstream testFile( ASSETS_DIR"/test.txt" );
      if ( !testFile.is_open() ) {
          DBG_LOG( "Failed to open assets/test.txt" );
          return;
      }
  
      for (; std::getline( testFile, line ); )
      {
          DBG_LOG( line.c_str() );
      }
  }
</code></pre>

<p>To access the PS3 filesystem remotely, we can use the FTP server built into
the PS3 CFW. I can access the ftp server from my computer by mounting it in
a local directory using curlftpfs; then it's just a matter of copying the
files over:

<pre><code>curlftpfs ftp://192.168.0.14 ~/ps3_ftp/ # mount the ftp server
cp -r game ~/ps3_ftp/dev_hdd0/rsxtest/
</code></pre>

<p>On the ps3 side, to launch the game, we can find the self executable
in the multiman explorer and launch it from there (although ps3load should
still work, I think...)</p>

<img src="images/ps3_filesystem_5_22_2021.jpg" width="500px"/>

<h3>05/23/2021</h3>

<p>Got an untextured MD2 model working by modifying the MD2 model code from
<a href="../bgn_opengl_game_prg/index.html">Beginning OpenGL Game Programming</a>.

<p>I first ran into a file endianness issue:</p>
<img src="images/md2_endian_error_5_23_2021.png"/>
<p>The version field of the MD2 header (a 32bit integer) was being read as
0x08000000 instead of 0x00000008. I forgot that the Ps3 Cell CPU is big endian,
whereas my x86_64 desktop is little endian. The MD2 file fields are stored
as little endian as well. I chose to handle this on the PS3 by converting the
read in file fields from little to big endian during load:</p>
<pre><code>Md2Model.h:

// little endian to big endian
inline int32_t lend2bend32( int32_t lend )
{
    char* ptr = (char*)&lend;
    return (ptr[3] &lt;&lt; 24) |
           (ptr[2] &lt;&lt; 16) |
           (ptr[1] &lt;&lt; 8)  |
           (ptr[0]);
}
inline float lend2bend32f( float lend )
{   
    float res;
    char* ptr = (char*)&lend;
    char* rPtr = (char*)&res;
    rPtr[0] = ptr[3];
    rPtr[1] = ptr[2];
    rPtr[2] = ptr[1];
    rPtr[3] = ptr[0];
    return res;
}
inline int16_t lend2bend16( int16_t lend )
{
    char* ptr = (char*)&lend;
    return (ptr[1] &lt;&lt; 8) |
           (ptr[0]);
}

Md2Model.cpp:
...
READ_DATA( lend2bend32( header.skinOffset ), skins, lend2bend32( header.numSkins ), Skin);
READ_DATA( lend2bend32( header.texCoordOffset ), md2TexCoords, lend2bend32( header.numTexCoords )
READ_DATA( lend2bend32( header.triangleOffset ), triangles, lend2bend32( header.numTriangles ), T

for ( TexCoord&amp; tc : md2TexCoords )
{
    tc.s = lend2bend16( tc.s );
    tc.t = lend2bend16( tc.t );
}   
for ( Triangle&amp; tr : triangles )
{
    tr.vertIndex[0] = lend2bend16( tr.vertIndex[0] );
    tr.vertIndex[1] = lend2bend16( tr.vertIndex[1] );
    tr.vertIndex[2] = lend2bend16( tr.vertIndex[2] );
    tr.texCoordIndex[0] = lend2bend16( tr.texCoordIndex[0] );
    tr.texCoordIndex[1] = lend2bend16( tr.texCoordIndex[1] );
    tr.texCoordIndex[2] = lend2bend16( tr.texCoordIndex[2] );
}  
...
// and similar for other locations with int16_t/int32_t/float
</code></pre>

<p>I also had to swap the Vec3 class with Vector3 (from the psl1ght library),
and define a basic Vector2 struct:</p>
<pre><code>struct KeyFrame
{
    f32 scale[3];     // use to multiply and add Vertex::v
    f32 translate[3];
    char name[16];
    std::vector&lt;Vertex&gt; md2Vertices;
    std::vector&lt;Vector3&gt; vertices; // converted result vertices
};
...
struct Vector2
{
    f32 u,v;
};
</code></pre>

<p>Then I replaced the opengl buffering with rsx memory buffering like
in the torus/sphere classes:</p>

<pre><code>
genBuffers:

m_meshBuffer-&gt;cnt_vertices = interpolatedFrame.vertices.size();
m_meshBuffer-&gt;vertices =
    (S3DVertex*)rsxMemalign( 128, 
                             m_meshBuffer-&gt;cnt_vertices * sizeof(S3DVertex) );
if ( !m_meshBuffer-&gt;vertices ) {
    DBG_LOG( "Failed to alloc vertices\n" );
    return false; 
}   
m_meshBuffer-&gt;indices = nullptr;
if ( texCoords.size() != interpolatedFrame.vertices.size() ) {
    DBG_LOG( "Tex coords size != vertices size (%lu, %lu)\n",
            texCoords.size(), interpolatedFrame.vertices.size() );
    return false;
}
for ( u32 i = 0; i &lt; m_meshBuffer-&gt;cnt_vertices; ++i )
{
    Vector3&amp; pos = interpolatedFrame.vertices[i];
    m_meshBuffer-&gt;vertices[i] = S3DVertex( pos.getX(), pos.getY(), pos.getZ(),
                                           0.0f, 1.0f, 0.0f, // TODO - normals
                                           texCoords[i].u, texCoords[i].v );
}
return true;

Update:

...
// Update RSX memory
for ( u32 i = 0; i &lt; m_meshBuffer-&gt;cnt_vertices; ++i )
{
    Vector3&amp; pos = interpolatedFrame.vertices[i];
    m_meshBuffer-&gt;vertices[i] = S3DVertex( pos.getX(), pos.getY(), pos.getZ(),
                                           0.0f, 1.0f, 0.0f, // TODO - normals
                                           texCoords[i].u, texCoords[i].v );
}
</code></pre>

<p>The md2 model also needs to be drawn with triangle arrays instead of indices.
I found rsxDrawVertexArray() in the psl1ght doxygen on the same page as
rsxDrawIndexArray() used previously, on the commands.h file reference:</p>
<img src="images/rsxdrawvertexarray_doxygen_5_23_2021.png"/>

<p>Then a slight modification to Entity::Render() to check wether to draw
with indices or arrays:</p>
<pre><code>...
if ( m_meshBuffer-&amp;gt;indices != nullptr )
{
    rsxAddressToOffset( &amp;m_meshBuffer-&amp;gt;indices[0], &amp;offset );
    rsxDrawIndexArray( m_context,
                       GCM_TYPE_TRIANGLES,        // u32 type
                       offset,                    // u32 offset
                       m_meshBuffer-&amp;gt;cnt_indices, // u32 count
                       GCM_INDEX_TYPE_16B,        // u32 data_type
                       GCM_LOCATION_RSX );        // u32 location
}
else
{
    rsxDrawVertexArray( m_context,
                        GCM_TYPE_TRIANGLES,
                        0,
                        m_meshBuffer-&gt;cnt_vertices );
}
</code></pre>

<p>Finally, in order to update the md2's animation, I added a GameTimer
class in main.cpp, based off ppu/include/sys/systime.h sysGetCurrentTime()</p>
<pre><code>class GameTimer
{
public:
    GameTimer()
    {   
        GetCurSecNsec( &amp;m_lastSec, &amp;m_lastNsec );
        m_FPS = 0.0f;
    }   
    ~GameTimer()
    {}  
    void Update()
    {   
        u64 curSec;
        u64 curNsec;
        GetCurSecNsec( &amp;curSec, &amp;curNsec );

        u64 secDiff = curSec - m_lastSec;
        u64 nsecDiff = (curNsec &lt; m_lastNsec) ? m_lastNsec - curNsec : curNsec - m_lastNsec;

        m_deltaMs = (float( secDiff ) * 1000.0f) +
                    (float( nsecDiff ) / 1000000.0f);
        m_lastSec = curSec;
        m_lastNsec = curNsec;

        ++m_framesCount;
        m_fpsTimeCount += m_deltaMs;
        if ( m_fpsTimeCount / 1000.0f &gt;= m_fpsDuration )
        {
            m_FPS = ( m_fpsTimeCount / 1000.0f ) * m_framesCount;
            m_framesCount = 0;
            m_fpsTimeCount = 0.0f;
        }
    }
    float GetDeltaMS() { return m_deltaMs; }
    float GetFPS() { return m_FPS; }
private:
    float m_deltaMs; // time passed since last update
    float m_FPS;
    u64 m_lastSec;
    u64 m_lastNsec;
    u32 m_framesCount = 0;
    float m_fpsTimeCount = 0.0f;
    const float m_fpsDuration = 1.0f; // seconds until update fps

    inline void GetCurSecNsec( u64* sec, u64* nsec )
    {
        sysGetCurrentTime( sec, nsec );
    }
};
</code></pre>

<p>The code in main to then load and draw the md2 model is:</p>
<pre><code>static Md2Model g_Ogro;
...
    if ( !g_Ogro.Init( g_Renderer.GetGcmContext() ) ) {
        DBG_LOG( "Failed to init md2 model ogro\n" );
        return;
    }
    if ( !g_Ogro.Load( ASSETS_DIR"/models/Ogro/tris.md2" ) ) {
        DBG_LOG( "Failed to load assets/models/Ogro/tris.md2\n" );
        return;
    } else {
        DBG_LOG( "Success loading assets/models/Ogro/tris.md2\n" );
    }
    g_Ogro.SetAnimation( Md2Model::Animation::Idle );
...
g_Timer.Update();
g_Ogro.Update( g_Timer.GetDeltaMS() );
...
modelMatrix = Matrix4::scale( Vector3( 0.25f, 0.25f, 0.25f ) );
modelMatrix.setTranslation(Vector3(3.0f,0.0f,-8.0f));

modelMatrixIT = inverse(modelMatrix);
modelViewMatrix = transpose(viewMatrix*modelMatrix);

objEyePos = modelMatrixIT*eye_pos;

g_Shader.Use();
g_Shader.SetVertexProgParam( "projMatrix", (float*)&amp;g_ProjMatrix );
g_Shader.SetVertexProgParam( "modelViewMatrix", (float*)&amp;modelViewMatrix );

g_Renderer.RenderEntity( g_Ogro );
</code></pre>

<p>Which gives us an unproperly textured model:</p>

<img src="images/untextured_md2_5_23_2021.gif"/>

<p>As a side note, I found you can added files to the rpcs3 emulator by
simply placing files in the appropriate directory in the same folder
as the emulator executable:</p>

<img src="images/rpcs3_folder_layout_5_23_2021.png"/>

<p>Next was texture loading. Like the Md2Model class, I copied and modified the Targa Image 
loading implementation from beginning opengl game programming. Like the .md2 model file,
the .tga texture needs to be converted from little to big endian. Luckily, there are only
4 fields in the file header that are larger than 1 byte and hence need to be flipped
(xOrigin, yOrigin, width, and height):</p>
<pre><code>struct Header
{
    uint8_t idLength;
    uint8_t colorMapType;
    uint8_t imageTypeCode;
    uint8_t colorMapSpec[5];
    uint16_t xOrigin;
    uint16_t yOrigin;
    uint16_t width;
    uint16_t height;
    uint8_t bpp;        // bits per pixel
    uint8_t imageDesc;
};
</code></pre>

<p>Other than that I didn't really need to modify the Targa code at all, just remove
the OpenGL buffer function. To load the texture data for the PS3 GPU, I made the
Targa::Image class a child of the Texture class, and added the Texture::Init function
to Targa::Image::Load:</p>

<pre><code>
namespace Targa
{
...
class Image : public Texture
{
// internally calls Texture::Init()
bool Load( gcmContextData* context, const std::string&amp; fileName );
...
bool Image::Load( gcmContextData* context, const std::string&amp; fileName )
{
...
    return Texture::Init( context,
                          imageData.data(),
                          width,
                          height,
                          bytesPerPixel );
}
</code></pre>

<p>Within the Texture class, I had to modify the init function to account
for textures with 3 bytes per pixel (no alpha), which defaults to an alpha
value of 255 instead:</p>
<pre><code>
bool Texture::Init( gcmContextData* context, u8* pixelData, u32 width, u32 height, u32 bytesPerPixel )
{
...
    m_buffer = (u32*)rsxMemalign( 128, width * height * 4 ); // force 4 bytes per pixel
...
    DBG_ASSERT( bytesPerPixel == 4 || bytesPerPixel == 3 );
    u8* buffer = (u8*)m_buffer;
    for ( u32 i = 0; i &lt; width * height * 4; i += 4 )
    {
        buffer[ i + 1 ] = *pixelData++; // r
        buffer[ i + 2 ] = *pixelData++; // g
        buffer[ i + 3 ] = *pixelData++; // b
        if ( bytesPerPixel == 4 ) {
            buffer[ i + 0 ] = *pixelData++; // a
        } else {
            buffer[ i + 0 ] = 255;
        }
    }
...
</code></pre>

<p>Initially the texture wasn't displaying right on the model; it turned out to be a bug
where I was converting the Md2 texture coordinates from little to big endian twice; so I was
ending up at little endian again. Fixing that we now see a glorious Ogro model:</p>

<img src="images/textured_md2_5_23_2021.gif"/>

<h3>06/05/2021</h3>

<p>Working on getting MD5 Skeletal Animation from Newcastle tutorials on PS3.
To start, I replaced the Newcastle Vector3, Vector4, Matrix3, and Matrix4 classes
with the PS3 SDK SIMD optimized classes. Additionally, the OpenGL code had to be
replaced with the PS3 RSX memory/vertex code. This included adding support
for 32-bit indices instead of 16-bit indices, due to the number of vertices
required.</p>

<pre><code>DBG_LOG( "Generating RSX buffers\n" );

if ( vertices == nullptr ) {
    DBG_LOG( "vertices null!\n" );
    return false;
}
m_meshBuffer-&gt;cnt_vertices = numVertices;
m_meshBuffer-&gt;vertices =
    (S3DVertex*)rsxMemalign( 128,
                             m_meshBuffer-&gt;cnt_vertices * sizeof(S3DVertex) );
if ( !m_meshBuffer-&gt;vertices ) {
    DBG_LOG( "Failed to alloc vertices\n" );
    return false;
}

if ( indices )
{
    m_meshBuffer-&gt;cnt_indices = numIndices;
    m_meshBuffer-&gt;indices = nullptr;
    m_meshBuffer-&gt;indices32 =
        (u32*)rsxMemalign( 128, m_meshBuffer-&gt;cnt_indices * sizeof(u32) );
    if ( !m_meshBuffer-&gt;indices32 ) {
        DBG_LOG( "Failed to alloc indices32\n" );
        free( m_meshBuffer-&gt;vertices );
        return false;
    }
}

for ( u32 i = 0; i &lt; m_meshBuffer-&gt;cnt_vertices; ++i )
{
    Vectormath::Aos::Vector3&amp; pos = vertices[i];
    Vector2&amp; texCoord = textureCoords[i];
    m_meshBuffer-&gt;vertices[i] = S3DVertex( pos.getX(), pos.getY(), pos.getZ(),
                                           0.0f, 1.0f, 0.0f, // TODO - normals
                                           texCoord.u, 1.0f - texCoord.v );
}

DBG_LOG( "mesh buffer num indices: %u\n", m_meshBuffer-&gt;cnt_indices );
for ( u32 i = 0; i &lt; m_meshBuffer-&gt;cnt_indices; ++i )
{
    m_meshBuffer-&gt;indices32[i] = indices[i];
}
...
if ( m_meshBuffer-&gt;indices != nullptr )
{
    rsxAddressToOffset( &amp;m_meshBuffer-&gt;indices[0], &amp;offset );
    rsxDrawIndexArray( m_context,
                       GCM_TYPE_TRIANGLES,        // u32 type
                       offset,                    // u32 offset
                       m_meshBuffer-&amp;gt;cnt_indices, // u32 count
                       GCM_INDEX_TYPE_16B,        // u32 data_type
                       GCM_LOCATION_RSX );        // u32 location
}
else if ( m_meshBuffer-&gt;indices32 != nullptr )
{
    rsxAddressToOffset( &amp;m_meshBuffer-&gt;indices32[0], &amp;offset );
    rsxDrawIndexArray( m_context,
                       GCM_TYPE_TRIANGLES,        // u32 type
                       offset,                    // u32 offset
                       m_meshBuffer-&gt;cnt_indices, // u32 count
                       GCM_INDEX_TYPE_32B,        // u32 data_type
                       GCM_LOCATION_RSX );        // u32 location
}

</code></pre>

<p>After those changes, I ended up with an initial bug:</p>

<img src="images/md5model_vecbug.png"/>

<p>Which, after debugging by logging values to text files and comparing between PC
version, narrowed down to this code:</p>

<pre><code>Vectormath::Aos::Vector4 res = ((joint.transform * weight.position) * weight.weightValue);
target-&gt;vertices[j] += Vectormath::Aos::Vector3( res.getX(), res.getY(), res.getZ() );
</code></pre>

<p>weight.position was a Vector3. Because of this, the multiply operator was handling the Matrix4/Vec3
length differently than the newcastle matrix code. Making weight.position a Vector4 instead fixed the
issue:</p>

<pre><code>Vectormath::Aos::Vector4 res = (( joint.transform *
                                  Vectormath::Aos::Vector4( weight.position, 1.0f ))
                                  * weight.weightValue );
target-&gt;vertices[j] += res.getXYZ();
</code></pre>

<img src="images/md5model_vecbug_fixed.png"/>

<p>Another bug:</p>

<pre><code>float oriX, oriY, oriZ;
from &gt;&gt; oriX &gt;&gt; oriY &gt;&gt; oriZ;
baseFrame.orientations[current].setX( oriX ); // bug! should be oriX,oriY,oriZ
baseFrame.orientations[current].setY( oriX );
baseFrame.orientations[current].setZ( oriX );
</code></pre>

<p>Better, but the animation is still weird/jerky, and the texture coordinates are still off...</p>
<img src="images/jerky_md5_anim_6_5_2021.gif"/>

<p>Turned out to be an issue with my game timer class</p>

<pre><code>//g_MD5Node-&gt;Update( g_Timer.GetDeltaMS() );
g_MD5Node-&gt;Update( 16.0f );
</code></pre>

<p>Hard coding the passed milliseconds made the animation nice and
smooth as expected</p>

<img src="images/md5_anim_non_jerky_6_5_2021.gif"/>

<p>Modified the game timer code to combine both seconds and nanoseconds
into just nanoseconds:</p>

<pre><code>//u64 secDiff = curSec - m_lastSec;                                                          
//u64 nsecDiff = (curNsec &lt; m_lastNsec) ? m_lastNsec - curNsec : curNsec - m_lastNsec;
u64 curNano = (curSec * 1e9) + curNsec;
u64 lastNano = (m_lastSec * 1e9) + m_lastNsec;

//m_deltaMs = (float( secDiff ) * 1000.0f) +
//            (float( nsecDiff ) / 1000000.0f);
m_deltaMs = float((curNano - lastNano) / 1000000);
</code></pre>

<p>Next, to fix the texture, I had to flip the v coordinate, like is done
in the Md2 model class:</p>

<pre><code>for ( u32 i = 0; i &lt; m_meshBuffer-&gt;cnt_vertices; ++i )                                           
{                                                                                                
    Vectormath::Aos::Vector3&amp; pos = vertices[i];                                                 
    Vector2&amp; texCoord = textureCoords[i];
    m_meshBuffer-&gt;vertices[i] = S3DVertex( pos.getX(), pos.getY(), pos.getZ(),                   
                                              0.0f, 1.0f, 0.0f, // TODO - normals                   
                                              texCoord.u, 1.0f - texCoord.v ); // flipped v to 1.0f - v
}
</code></pre>

<p>And wallah! Fully textured and animated working on the console:</p>

<img src="images/md5_animated_working_fully_6_5_2021.gif"/>

<p>I loaded the proper texture outside of the MD5 class; TODO would be to auto
load the texture based on the file name within the MD5.</p>

<h3>06/06/2021</h3>

<p>Working on the heightmap terrain from Begginning Opengl Game Programming.
Similar to the MD5 model, I replaced Vector/Matrix classes with the
ps3 Vectormath::Aos::Vector3 versions. I also moved the texturing outside
of the class (into main for now).</p>

<p>The scale of the terrain compared to the MD5 model is quite different;
I'll have to either scale down the MD5 model or scale up the terrain.</p>

<p>I initially had a texturing issue:</p>

<img src="images/terrain_badtexture_6_6_2021.png" width="600px"/>

<p>Which viewing the zoomed out version, showed the texture was
not repeating over each terrain section. Looking at the texture
class code properties, I saw the texture was configured to clamp
instead of wrap, which matches viewing the zoomed out terrain.</p>

<p>Looking at the PSL1GHT doxygen, we can see the different
texture options:</p>

<img src="images/terrain_texture_doxygen_6_6_2021.png"/>

<p>I chose GCM_TEXTURE_REPEAT to use instead of GCM_TEXTURE_CLAMP:</p>

<pre><code>//rsxTextureWrapMode(m_context,shaderTexUnit,GCM_TEXTURE_CLAMP_TO_EDGE,GCM_TEXTURE_CLAMP_TO_EDGE,GCM_TEXTURE_CLAMP_TO_EDGE,0,GCM_TEXTURE_ZFUNC_LESS,0);
rsxTextureWrapMode(m_context,shaderTexUnit,GCM_TEXTURE_REPEAT,GCM_TEXTURE_REPEAT,GCM_TEXTURE_REPEAT,0,GCM_TEXTURE_ZFUNC_LESS,0);
</code></pre>

<img src="images/terrain_texture_repeat_6_6_2021.png" width="600px"/>

<p>Scaling the terrain by a factor of 20 we can now see the ground
in relation to the MD5 model:</p>

<img src="images/terrain_scaled_6_6_2021.png" width="600px"/>

<p>However, when I tried running it on my PS3 it didn't turn out so well:</p>

<img src="images/terrain_ps3_error_6_6_2021.jpg" width="600px"/>

<p>I guessed it had to do with the massive scaling and size difference between the terrain and MD5
model. After adding a scale option to the MD5 loading code and scaling it down to 1/20th its original
size, and then adjusting the camera, running on PS3 hardware worked again:</p>

<img src="images/terrain_ps3_working_6_6_2021.gif"/>

<h3>06/07/2021</h3>

<p>Got transparent texture for the tree object from beg. opengl game prog. working. I made a
static S3DVertex class member pointer, that way all Tree instances can share the same vertex
memory. I also changed the vertex/texture coordinate buffers to use triangles instead of
triangle strips, just because I was lazy and didn't want to figure out how to do that on the
ps3 (I think an additional 2 triangles won't kill us!).</p>

<pre><code>// static buffer instance
S3DVertex* Tree::s_vertices = nullptr;
...
static const size_t numVertices = 12;
m_meshBuffer-&gt;cnt_vertices = numVertices;
if ( s_vertices == nullptr )
{
    float vertices[numVertices*3] = 
    {
        // first square
        -1.0f, 0.0f, 0.0f, // bottom left
        1.0f,  0.0f, 0.0f, // bottom right
        -1.0f, 2.0f, 0.0f, // top left
        1.0f,  0.0f, 0.0f, // bottom right
        1.0f,  2.0f, 0.0f, // top right
        -1.0f, 2.0f, 0.0f, // top left

        // second square
        0.0f, 0.0f,  1.0f, // bottom left
        0.0f, 0.0f, -1.0f, // bottom right
        0.0f, 2.0f,  1.0f, // top left
        0.0f, 0.0f, -1.0f, // bottom right
        0.0f, 2.0f, -1.0f, // top right
        0.0f, 2.0f,  1.0f // top left
        
    };

    float texCoords[numVertices*2] =
    {
        // first square
        0.0f, 0.0f, // bottom left
        1.0f, 0.0f, // bottom right
        0.0f, 1.0f, // top left
        1.0f, 0.0f, // bottom right
        1.0f, 1.0f, // top right
        0.0f, 1.0f, // top left

        // second square
        0.0f, 0.0f, // bottom left
        1.0f, 0.0f, // bottom right
        0.0f, 1.0f, // top left
        1.0f, 0.0f, // bottom right
        1.0f, 1.0f, // top right
        0.0f, 1.0f, // top left
    };

    s_vertices = (S3DVertex*)rsxMemalign( 128,
                                          m_meshBuffer-&gt;cnt_vertices * sizeof(S3DVertex) );
    for ( size_t i = 0; i &lt; numVertices; ++i )
    {
        float* vertex = &amp;vertices[i*3];
        float* texCoord = &amp;texCoords[i*2];
        s_vertices[i] = S3DVertex( vertex[0], vertex[1], vertex[2],
                                    0.0f, 1.0f, 0.0f, // TODO - normals
                                    texCoord[0], texCoord[1] );
    }
}
m_meshBuffer-&gt;vertices = s_vertices;
m_meshBuffer-&gt;cnt_indices = 0;
m_meshBuffer-&gt;indices = nullptr;
m_meshBuffer-&gt;indices32 = nullptr;
</code></pre>

<p>Next, I updated fragment shader to allow alpha values:</p>
<pre><code>//float3 color = tex2D(texture, texcoord).xyz; // old
float4 color = tex2D(texture, texcoord); // new
    
//oColor = float4(color,1.0f); // old
oColor = color; // new
</code></pre>

<p>Yet the tree texture was showing black where it should be transparent:</p>

<img src="images/nontransparent_tree_6_7_2021.png"/>

<p>Hard coding red and green values in the shader showed that indeed worked:</p>

<img src="images/nontransparent_color_test_6_7_2021.png"/>

<p>After some poking around in the psl1ght doxygen, I found shader blending was
disabled by default. I added the following calls to Renderer::SetDrawEnv().
I was surprised rsxSetBlendFunc() needed to be called explicitly as well, I assumed
some default would have worked instead.</p>

<pre><code>rsxSetBlendEnable( context, GCM_TRUE ); // enable blending
rsxSetBlendEquation( context, GCM_FUNC_ADD, GCM_FUNC_ADD ); // default blend equation...
rsxSetBlendFunc( context, GCM_SRC_ALPHA, // sfcolor (source)
                          GCM_ONE_MINUS_SRC_ALPHA, // dfcolor (destination)
                          GCM_SRC_ALPHA, // sfalpha
                          GCM_ONE_MINUS_SRC_ALPHA ); // dfalpha
</code></pre>

<p>Which is called every Renderer::BeginFrame(). Now we have a transparent texture
for the tree as expected:</p>

<img src="images/transparent_tree_working_6_7_2021.png"/>


<h3>06/21/2021</h3>

<p>Added an orbit camera class based on "Game Programming in C++"
by Sanjay Madhav, chapter 9</p>

<p>Surprisingly, it worked basically on the first try, after replacing
Madhav's Vector/Quaternion code with the PSL1GHT library code:</p>

<pre><code>void OrbitCamera::Update( const float dt )
{
    // yaw quaternion about world up
    Vectormath::Aos::Quat yaw = Vectormath::Aos::Quat::rotationY(
        m_yawSpeed * dt );
 
    // transform offset and up by yaw
    m_offset = Vectormath::Aos::rotate( yaw, m_offset );
    m_up = Vectormath::Aos::rotate( yaw, m_up );
    
    // Compute camera forward and right
    // forward owner.position - (owner.position + offset)
    // = -offset
    Vectormath::Aos::Vector3 forward = -1.0f * m_offset;
    forward = normalize( forward );
    Vectormath::Aos::Vector3 right = Vectormath::Aos::cross( m_up, forward );
    right = Vectormath::Aos::normalize( right );
    
    // Create quaternion for pitch about camera right
    Vectormath::Aos::Quat pitch = Vectormath::Aos::Quat::rotation(
        m_pitchSpeed * dt, right );
    // transform offset and up by pitch
    m_offset = Vectormath::Aos::rotate( pitch, m_offset );
    m_up = Vectormath::Aos::rotate( pitch, m_up );
    
    // Create the lookat matrix
    m_viewMat = Vectormath::Aos::Matrix4::lookAt(
        Vectormath::Aos::Point3( m_target + m_offset ), // camera position
        Vectormath::Aos::Point3( m_target ), // camera target/look at
        m_up ); // up vector
}
</code></pre>

<p>Then, in main, I replaced the viewMatrix with the Camera 
GetViewMatrix() function. TODO is also to move the entity positions
within the entity class (for the model matrix):</p>

<pre><code>static OrbitCamera g_Camera;
...
modelViewMatrix = transpose(g_Camera.GetViewMatrix()*modelMatrix);
...
g_Camera.SetTarget( g_MD5Position );
g_Camera.Update( g_Timer.GetDeltaMS() );
//g_Camera.SetPitchSpeed( 0.0005f ); // rotate the camera
g_Camera.SetYawSpeed( 0.0005f );
</code></pre>

<p>TODO is to move the camera with the controller, but testing shows
valid rotation around our MD5 model target:</p>

<img src="images/orbit_camera_1_6_21_2021.gif"/><br/>
<img src="images/orbit_camera_2_6_21_2021.gif"/>

<h3>06/22/2021</h3>

<p>
Got model rotation/forward direction working. Added yaw, pitch, position,
forward speed, and a model matrix to the Entity class:
</p>

<pre><code>Vectormath::Aos::Matrix4 m_modelMat;
Vectormath::Aos::Vector3 m_position;
float m_yawSpeed; // yaw speed in radians/sec
float m_yaw; // yaw in radians
float m_yawRenderOffset; // additional yaw to add before rendering

float m_pitchSpeed; // pitch speed in radians/sec
float m_pitch; // pitch in radians

float m_forwardSpeed; // added to m_position based on calculated forward vec
</code></pre>

<p>Then Update() recalculates the model matrix (based on 
Madhav mentioned yesterday). It's currently limited to yaw rotation about
the Y axis.</p>

<pre><code>void Entity::Update( float dt )
{
    m_yaw += m_yawSpeed * dt;

    // TODO - account for pitch in forward as well
    // default forward points right; along x axis
    Vectormath::Aos::Vector3 forward( 1.0f, 0.0f, 0.0f );
    // rotate the right-pointing forward about Y axis based on yaw
    Vectormath::Aos::Quat yaw = Vectormath::Aos::Quat::rotationY( m_yaw );
    forward = Vectormath::Aos::rotate( yaw, forward );

    // move forward
    m_position = m_position + (forward * m_forwardSpeed * dt);

    // TODO - 
    // This doesn't allow for pitch or roll rotation...
    m_modelMat = Vectormath::Aos::Matrix4(
        Vectormath::Aos::Transform3(
            Vectormath::Aos::Quat::rotationY( m_yaw ),
            m_position ));
}
</code></pre>

<p>Next, added controller input to move/rotate the entity (Filter2D again
based on Madhav, except scaled controller values from -128 to 127 instead of 
-32768 32767:</p>

<pre><code>// input range 0-255, middle = 127
Vector2 Filter2D( int inputX, int inputY )
{
    const float deadZone = (8000.0f/32768.0f) * 127.0f;
    const float maxValue = (30000.0f/32768.0f) * 127.0f;

    Vector2 dir;
    dir.x = (float)(inputX) - 127.0f;
    dir.y = (float)(inputY) - 127.0f;

    float length = dir.Length();

    if ( length &lt; deadZone )
    {
        dir.x = 0.0f;
        dir.y = 0.0f;
    }
    else
    {
        // calculate fractional between dead zone and max value circles
        float f = ( length - deadZone ) / ( maxValue - deadZone );

        // clamp between 0 and 1
        if ( f &lt; 0.0f ) { f = 0.0f; }
        if ( f &gt; 1.0f ) { f = 1.0f; }

        // normalize vector and scale it to the fractional value
        dir.x *= f / length;
        dir.y *= f / length;
    }

    return dir;
}
...
// main loop
Vector2 analogDir = Filter2D( g_Pad.GetLeftAnalogX(),
                               g_Pad.GetLeftAnalogY() );
float dirLen = analogDir.Length();
g_MD5Node-&gt;SetForwardSpeed( -dirLen * 0.005f );
static bool isIdle = false;
if ( dirLen &gt; 0.000001f ) {
    float angle = atan2( -analogDir.y, analogDir.x );
    g_MD5Node-&gt;SetYaw( angle );
}

g_MD5Node-&gt;Update( g_Timer.GetDeltaMS() );
g_Camera.SetTarget( g_MD5Node-&gt;GetPosition() );
g_Camera.Update( g_Timer.GetDeltaMS() );

</code></pre>

<p>Then confirmed that we can rotate the entity and move it around:</p>

<img src="images/rotating_working_6_22_2021.gif"/>

<h3>06/23/2021</h3>

<p>Added the walking animation to the controlled MD5 Model, which turned out to
be way harder than I thought it would.</p>

<p>The first step was simple; load and play a different .md5anim file instead of
the idle anim:</p>

<pre><code>EXIT_ON_FAIL( g_MD5Data.AddAnim( ASSETS_DIR"/models/hellknight/idle2.md5anim" ),
              "Failed to load md5 anim\n",
              "Sucess loading md5 anim\n" );
EXIT_ON_FAIL( g_MD5Data.AddAnim( ASSETS_DIR"/models/hellknight/walk7.md5anim" ),
              "Failed to load md5 anim\n",
              "Sucess loading md5 anim\n" );
//g_MD5Node-&gt;PlayAnim( ASSETS_DIR"/models/hellknight/idle2.md5anim" );
g_MD5Node-&gt;PlayAnim( ASSETS_DIR"/models/hellknight/walk7.md5anim" );
</code></pre>

<p>But that causes the model to move forward during its anim sequence:</p>

<img src="images/walking_notworking_6_23_2021.gif"/>

<p>Based on <a href="https://www.gamedev.net/forums/topic/539631-md5---how-to-make-a-character-walk-according-to-animation/">
this post</a>, to try and keep the model from moving forward during its walk cycle,
I tried subtracting the interpolated current and next root joint's anim
transform from the model position, but the result was very jerky/not smooth:</p>

<pre><code>// MD5Anim.cpp
skelJoint.transform = MD5FileData::conversionMatrix * skelJoint.localTransform;
curRootTransform = skelJoint.transform;
Vectormath::Aos::Matrix4 nextLocalTransform;
Vectormath::Aos::Transform3 nextT3( animQuat, nextAnimPos ); // don't care about rotation, only using position
nextLocalTransform = Vectormath::Aos::Matrix4( nextT3 );
nextRootTransform = MD5FileData::conversionMatrix * nextLocalTransform;
...
// MD5Node.cpp
Vectormath::Aos::Matrix4&amp; rootMat = currentAnim-&gt;GetCurRootTransform();
Vectormath::Aos::Matrix4&amp; nextRootMat = currentAnim-&gt;GetNextRootTransform();
Vectormath::Aos::Vector3 offset = rootMat.getTranslation();
Vectormath::Aos::Vector3 nextOffset = nextRootMat.getTranslation();

// LERP between the offsets
if ( currentAnim-&gt;GetFrameRate() &lt; 0.000001f ) {
    //DBG_LOG( "WARN: current anim frame rate 0.0f\n" );
    return Vectormath::Aos::Vector3( 0.0f, 0.0f, 0.0f );
}
// frameTime is in milliseconds not seconds, so frame rate scaled by 1000
float t = frameTime / ( 1000.0f / currentAnim-&gt;GetFrameRate() );
if ( t &lt; 0.0f || t &gt; 1.0f ) {
    t = 0.0f;
    DBG_LOG( "ERROR - bad t (frameTime, frameRate: %f, %f )\n", frameTime, currentAnim-&gt;GetFrameRate() );
}
offset = Vectormath::Aos::lerp( 1.0f - t, offset, nextOffset );
return offset;
...
// Entity.cpp
// TODO - account for pitch in forward as well
// default forward points right; along x axis
Vectormath::Aos::Vector3 forward( 1.0f, 0.0f, 0.0f );
Vectormath::Aos::Vector3 moveOffset( GetMovingAnimOffset() );
// rotate the right-pointing forward about Y axis based on yaw
Vectormath::Aos::Quat yaw = Vectormath::Aos::Quat::rotationY( m_yaw );
forward = Vectormath::Aos::rotate( yaw, forward );
moveOffset = Vectormath::Aos::rotate( yaw, moveOffset );

// move forward
m_position = m_position + (forward * m_forwardSpeed * dt);

// TODO
// This doesn't allow for pitch or roll rotation...
m_modelMat = Vectormath::Aos::Matrix4(
    Vectormath::Aos::Transform3(
        Vectormath::Aos::Quat::rotationY( m_yaw ),
        m_position - moveOffset )); // offset position by animation offset
</code></pre>

<p>Again, this didn't work well. I next tried setting the root joint
animation matrix translation component directly to zero, which worked like a charm!
As well as being much simpler and less expensive</p>

<pre><code>// MD5Anim.cpp
...
skelJoint.transform = MD5FileData::conversionMatrix * skelJoint.localTransform;
Vectormath::Aos::Vector3 transVec( 0.0f, 0.0f, 0.0f ); // don't move the model's position at all please
skelJoint.transform.setTranslation( transVec );
</code></pre>

<p>So now we can move our model directly with the controller and trigger the walking animation:</p>

<img src="images/walking_working_6_23_2021.gif"/>

<h3>07/25/2021</h3>

<p>Working on porting <a href="https://www.amazon.com/Game-Programming-Creating-Games-Design/dp/0134597206">Sanjay Madhav's Game Programming book</a>
to PS3, starting with Chapter 8 (Input system and asteroids game)</p>

<p>PSL1GHT comes with a port SDL 1.2, not 2.0, so the first thing was converting the relevant code.
It's mostly using SDL_Surfaces for everything instead of SDL_Renderer and SDL_Window. Additionally,
the chapter uses OpenGL to draw everything in 2D. I'm hoping just for this chapter's code to just use SDL
and worry about PS3 RSX programming later. However, one problem I need to fix currently is that SDL 1.2
doesn't include the ability to rotate surfaces/sprites, so I'll either have to do that manually to the 
surface pixels or suck it up and program with the rsx/shaders so I can do rotation that way.</p>

<p>So far I have the ship sprite drawn (using SDL_image) and input working. I had an issue at first
running on PS3 hardware that RPCS3 emulator didn't catch, related to SDL initialization:</p>

<pre><code>
// This code freezes on PS3 hardware
if (SDL_Init(SDL_INIT_VIDEO|SDL_INIT_AUDIO|SDL_INIT_JOYSTICK|SDL_INIT_TIMER) != 0)
{
    SDL_Log("Unable to initialize SDL: %s", SDL_GetError());
    return false;
}
mWindow = SDL_SetVideoMode(1024, 768, 32, SDL_HWSURFACE);
if (!mWindow) {
    SDL_Log("Failed to set video mode: %s\n", SDL_GetError());
    return false;
}

// This code works/doesn't freeze
if (SDL_Init(SDL_INIT_VIDEO|SDL_INIT_JOYSTICK) != 0)
{
    SDL_Log("Unable to initialize SDL: %s", SDL_GetError());
    return false;
}

mWindow = SDL_SetVideoMode(1024, 768, 0, SDL_FULLSCREEN);
if (!mWindow) {
    SDL_Log("Failed to set video mode: %s\n", SDL_GetError());
    return false;
}
</code></pre>

<p>This was based on looking at <a href="https://github.com/kernow5000/shoot">kernow5000s</a>
, which looking at it again now I noticed doesn't actually target the PS3. On github at least
through searching, I don't find many results for "sdl ps3."</p>

<p>Currently, after creating a few lazer objects the PS3 freezes as well. This happens on
both the rpcs3 emulator and hardware:</p>

<pre><code>if (input.GetMappedButtonState("Fire") == EHeld
    &amp;&amp; mLaserCooldown &lt;= 0.0f)
{
    // this commented out code causes freeze after a few calls...
    // Create a laser and set its position/rotation to mine
    //Laser* laser = new Laser(GetGame());
    //laser-&gt;SetPosition(GetPosition());
    //laser-&gt;SetRotation(GetRotation());
    //SDL_Log("Ship fire");

    // Reset laser cooldown (quarter second)
    mLaserCooldown = 0.25f;
}
</code></pre>

<p>Which I'm assuming is related to dynamic memory allocation. That's a TODO for later.
Next, SDL 1.2 doesn't have direct button mappings for the PS3 controller, you just specify which
button via an integer, so I added some defines after testing which integer matches
what button:</p>

<pre><code>// How ps3 controller buttons are mapped to SDL buttons
#define PS3_BUTTON_LEFT     0
#define PS3_BUTTON_DOWN     1
#define PS3_BUTTON_RIGHT    2
#define PS3_BUTTON_UP       3
#define PS3_BUTTON_START    4
#define PS3_BUTTON_RANALOG  5
#define PS3_BUTTON_LANALOG  6
#define PS3_BUTTON_SELECT   7
#define PS3_BUTTON_SQUARE   8
#define PS3_BUTTON_CROSS    9
#define PS3_BUTTON_CIRCLE   10
#define PS3_BUTTON_TRIANGLE 11
#define PS3_BUTTON_R1       12
#define PS3_BUTTON_L1       13
#define PS3_BUTTON_R2       14
#define PS3_BUTTON_L2       15
</code></pre>

<p>Finally, just a note it seems I can't get variable L2/R2 trigger
values, they are just mapped as buttons. It may be worth ditching SDL
for input and just using PSL1GHT directly in this case...</p>

<p>The current progress of the chapter8 code looks like this:</p>

<img src="images/chapter8_7_25_2021.png"/>

<h3>07/27/2021</h3>

<p>Basically finished chapter 8, the only thing missing is sprite rotation, which I'm not sure I'll bother with,
sense I wanted to focus on 3d next anyways.</p>

<p>The issue I had with Lasers crashing the code turned out to be a bug I had when re-introducing the Actors
back into the game class:</p>

<pre><code>// Bugged code I wrote - deleting an entry from mActors instead of mPendingActors,
// causing invalid memory access!
void Game::RemoveActor(Actor* actor)
{
    // Is it in pending actors?
    auto iter = std::find(mPendingActors.begin(), mPendingActors.end(), actor);
    if (iter != mPendingActors.end())
    {
        // Swap to end of vector and pop off (avoid rease copies)
        std::iter_swap(iter, mActors.end() - 1);
        mActors.pop_back();
    }
}

// Proper version, fixed the bug:
void Game::RemoveActor(Actor* actor)
{
    // Is it in pending actors?
    auto iter = std::find(mPendingActors.begin(), mPendingActors.end(), actor);
    if (iter != mPendingActors.end())
    {
        // Swap to end of vector and pop off (avoid erase copies)
        std::iter_swap(iter, mPendingActors.end() - 1);
        mPendingActors.pop_back();
    }

    // Is it in actors?
    iter = std::find(mActors.begin(), mActors.end(), actor);
    if (iter != mActors.end())
    {
        // Swap to end of vector and pop off (avoid erase copies)
        std::iter_swap(iter, mActors.end() - 1);
        mActors.pop_back();
    }
}
</code></pre>

<p>After that, I had to modify the MoveComponent class screen position
calculation from OpenGL coordinates where the center of the screen is 0,0
to SDL coordinates where the top left of the screen is 0,0:</p>

<pre><code>// Old OpenGL coordinates code:
// Screen wrapping (for asteroids)
if (pos.x &lt; -512.0f) { pos.x = 510.0f; }
else if (pos.x &gt; 512.0f) { pos.x = -510.0f; }
if (pos.y &lt; -384.0f) { pos.y = 382.0f; }
else if (pos.y &gt; 384.0f) { pos.y = -382.0f; }
mOwner-&gt;SetPosition(pos);

// New SDL coordinates version:
float sWidth = (float)mOwner-&gt;GetGame()-&gt;GetScreenWidth();
float sHeight = (float)mOwner-&gt;GetGame()-&gt;GetScreenHeight();

// Screen wrapping (for asteroids)
if (pos.x &lt; 0.0f) { pos.x = sWidth-1; }
else if (pos.x &gt; sWidth) { pos.x = 1.0f; }
if (pos.y &lt; 0.0f) { pos.y = sHeight-1; }
else if (pos.y &gt; sHeight) { pos.y = 1.0f; }
mOwner-&gt;SetPosition(pos);
</code></pre>

<p>Now, the code acts like the original book version except a) the sprites don't rotate
and b) only a square in the center of the screen is used; assuming that's because
I hard-coded the window resolution to 1024x768:</p>

<img src="images/chapter_08_working_7_27_2021.gif"/>

<p>I now have a git repo for the code 
<a href="https://bitbucket.org/williamblair/game_programming_cpp_ps3/src/master/">here</a></p>

<h3>07/28/2021</h3>

<p>Working on changing SDL rendering to rsx 3D rendering so we can a) use the full screen
and b) rotate sprites. It'll also be needed for the further chapters anyways to render
3D.</p>

<p>Currently have the Renderer class, Shader class seemingly working (techincally shader hasn't been
tested yet). Renderer is initialized in Game class and clears the screen white.</p>

<p>Started texture class, not finished. Planning to use SDL_image to load the texture data
to upload to the rsx as a texture, in place of SOIL in the book code.</p>

<p>Also todo, implement the VertexArray class to have a PS3 version of that, as opposed to storing
the vertex data in an object in the game class.</p>

<h3>07/30/2021</h3>

<p>Got the 3D/shader version of chapter 08 fully working now.</p>

<p>I had the most issue with matrices and shader transformations. The book uses (I think)
a left-handed coordinate system and stores the matrices in row-major order which is
different than the OpenGL centric manner I'm used to seeing (right-handed coordinates
and column major order). The book tells OpenGL to transpose the matrices as they are sent
to the shader (GL_TRUE):</p>
<pre><code>// book code
void Shader::SetMatrixUniform(const char* name, const Matrix4&amp; matrix)
{
	// Find the uniform by this name
	GLuint loc = glGetUniformLocation(mShaderProgram, name);
	// Send the matrix data to the uniform
	// GL_TRUE - "For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable."
	glUniformMatrix4fv(loc, 1, GL_TRUE, matrix.GetAsFloatPtr());
}
</code></pre>
<p>Then in the vertex shader, the multiplcation order is backwards compared to what I've
seen previously:</p>
<pre><code>// Transform position to world space, then clip space
gl_Position = pos * uWorldTransform * uViewProj;
</code></pre>
<p>The question then is how does this translate to the PSX/rsx? After some experimentation,
the following works for me; however, I hard-coded the z value to zero otherwise it
was freaking out:</p>
<pre><code>ePosition = mul(mul(transpose(uViewProj),transpose(uWorldTransform)),pos);
ePosition.z = 0.0;
</code></pre>
<p>With this however, the sprite rotations were backwards and the y-coordinate was
backwards also. To work around this, I negated the actor rotation and y-position
when calculating the world matrix:</p>
<pre><code>// Scale, then rotate, then translate
mWorldTransform = Matrix4::CreateScale(mScale);
mWorldTransform *= Matrix4::CreateRotationZ(-mRotation); // negated rotation and y position below
mWorldTransform *= Matrix4::CreateTranslation(Vector3(mPosition.x, -mPosition.y, 0.0f));
</code></pre>

<p>I'll probably end up replacing the book's matrix/vector classes with the psl1ght
provided versions to use hardware accelerated computations anyways for the next
chapters. We now have a version that uses the entire available screen space and hardware
accelerated drawing (Also my first time converting a video to webm below; it's only
178KB! Seems to be a good alternative to gifs...)</p>

<p>Recorded from rpcs3: (I confirmed it works on hardware too)</p>
<video controls width="600">
    <source src="images/chapter8_7_30_2021_working.webm" type="video/webm"/>
</video>

<p>
<a href="../../index.html">&lt;-- Back to Home</a>
</p>

</div> <!-- contentDiv -->
</div> <!-- bodyDiv -->

</body>
</html>
