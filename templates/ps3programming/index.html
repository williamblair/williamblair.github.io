<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>BJ's Website</title>
  <link rel="stylesheet" type="text/css" href="../../site.css"/>
  
</head>
<body>

<div id="bodyDiv">

<div id="contentDiv">

<h1>PS3 Programming Log</h1>
<img alt="PS2 Logo" style="float:right; margin:5px;" src="https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Flogonoid.com%2Fimages%2Fplaystation-3-logo.png&f=1&nofb=1" width="400px"/>

<p>My working log for learning programming for the Playstation 3. Inspired
by <a href="https://research.ncl.ac.uk/game/mastersdegree/">Newcastle University's
Computer Game Engineering Content</a> where they have a few sections on PS3 programming.
Unfortunately, they seem to use the official SONY PS3 Devkit, which of course we don't
have access too. There is however an open source ps3sdk we can use:
<a href="https://github.com/ps3dev">https://github.com/ps3dev</a>. I've followed so far
the first introduction section from the Newcastle content and it seems like a good resource;
the only drawback is it's Windows and Visual Studio oriented. (Another future project TODO -
convert their example code to SDL/GLEW for Linux support!)</p>

<p>For PS3 my current goal is
to get MD5 skeletal animation working
<a href="https://research.ncl.ac.uk/game/mastersdegree/graphicsforgames/skeletalanimation/">
from the NewCastle tutorial</a>, and possibly 
the GLTF skeletal animation from <a href="https://www.amazon.com/Hands-Game-Animation-Programming-implementation/dp/1800208081">
Hands-On C++ Game Animation Programming</a>. Also, it'd be cool to get
<a href="https://github.com/gzorin/RSXGL">RSXGL</a> working, which is an OpenGL 3.1
implementation, but I haven't had any luck so far.</p>

<p>The source code is currently here: <a href="https://bitbucket.org/williamblair/ps3devprogs">https://bitbucket.org/williamblair/ps3devprogs</a></p>

<h3>05/15/2021</h3>

<p>Looking through the
<a href="https://github.com/ps3dev/PSL1GHT/tree/master/samples/graphics/rsxtest">
psl1ght graphics example</a>. Seems actually pretty similar to OpenGL: we have shaders,
buffer attributes, texture formats, etc...
</p>
<p>The shaders are NOT compiled and loaded at runtime like in OpenGL; instead they are
pre-compiled at the same time as the main program and stored as byte arrays and included
as C headers.</p>
<p>The shader language seems pretty similar to GLSL except programs take in
a bunch of function arguments intead of global vars:</p>
<pre><code>void main
(
    float3 vertexPosition : POSITION,
    float3 vertexNormal : NORMAL,
    float2 vertexTexcoord : TEXCOORD0,
    
    uniform float4x4 projMatrix,
    uniform float4x4 modelViewMatrix,
    
    out float4 ePosition : POSITION,
    out float4 oPosition : TEXCOORD0,
    out float3 oNormal : TEXCOORD1,
    out float2 oTexcoord : TEXCOORD2
)
{
    ePosition = mul(mul(projMatrix,modelViewMatrix),float4(vertexPosition,1.0f));
    
    oPosition = float4(vertexPosition,1.0f);
    oNormal = vertexNormal;
    oTexcoord = vertexTexcoord;
}
</code></pre>

<p>Vertex buffer data seems to be stored on GPU memory but accessible from the CPU.
The memory is allocated via rsxMemalign() and then vertex data is copied into it.
There is an 'offset' associated with this allocation used as arguments to other functions;
I'm assuming this is like the address of the memory block within GPU memory.</p>
<pre><code>m_meshBuffer-&gt;vertices = (S3DVertex*)rsxMemalign(128,m_meshBuffer-&gt;cnt_vertices*sizeof(S3DVertex));
...
m_meshBuffer-&gt;vertices[i] = S3DVertex(pos.getX(),pos.getY(),pos.getZ(),normal.getX(),normal.getY(),normal.getZ(),tu,static_cast<f32>(ay*RECIPROCAL_PI));
u32 offset = 0;    
rsxAddressToOffset( &amp;m_meshBuffer-&gt;vertices[0].pos, &amp;offset );
</code></pre>
<p>The S3DVertex and SBuffer classes are included with the psl1ght sample as custom objects (mesh.h), so we
don't have to use those if we don't want to.</p>
<p>As a side note, the main CPU is the PowerPC Processor Unit (PPU) and then there are 
eight SPUs to execute separate programs to run in parallel if desired (see 
<a href="https://mirrors.edge.kernel.org/pub/linux/kernel/people/geoff/cell/ps3-linux-docs/CellProgrammingTutorial/BasicsOfCellArchitecture.html">here</a>).
RSX stands for reality synthesizer and is the PS3 GPU (see <a href="https://www.psdevwiki.com/ps3/RSX">here</a>.)
</p>
<p>The compiled program results in a .elf file (similar to the PS2), but for the PS3 this
needs to be converted into a .self file which I think is an encrypted version of the .elf.
Using ps3load with the elf file didn't seem to work but using the .self file did. Conversion
to a .self is done automatically with the ps1light sample makefile.</p>

<p>I remorked the sample code to remove the lighting (to simplify things), then made the
following C++ classes:</p>
<ul>
<li>Shader</li>
<li>Texture</li>
<li>Entity
    <ul>
     <li>Sphere</li>
     <li>Torus</li>
     <li>Cube</li>
    </ul>
</li>
</ul>

<p>Rendering an entity then works the same as opengl, where you set shader
and vertex buffer attributes, then draw indexed arrays:</p>
<pre><code>g_Shader.Use();
g_Shader.SetVertexProgParam( "projMatrix", (float*)&amp;P );
g_Shader.SetVertexProgParam( "modelViewMatrix", (float*)&amp;modelViewMatrix );
...
g_Sphere.Render();
</code></pre>

<p>TODO is to make a rendering class, also have a single shader SetAttribute
function for both vertex shader and fragment shader attribs.
I also made a Logging namespace and macro which logs to both
TTY/stdout and the debug font sample to the screen:</p>
<pre><code>#define DBG_LOG(format, ...)                                            \
    sprintf( Log::dbgPrintStr, "%s:%d: ", __FILE__, __LINE__ );         \
    Log::len = strlen( Log::dbgPrintStr );                              \
    sprintf( &amp;Log::dbgPrintStr[ Log::len ], format, ##__VA_ARGS__ );    \
                                                                        \
    printf( Log::dbgPrintStr );                                         \
                                                                        \
    Log::dbgLogHistory.push_back( Log::dbgPrintStr );                   \
    if ( Log::dbgLogHistory.size() &gt; LOG_HISTORY_LEN ) {                \
        Log::dbgLogHistory.pop_front();                                 \
    }
</code></pre>

<p>I originally tried an inline function but that resulted in the function
not actually being able to be inlined, and thus the __FILE__ and __LINE__
preprocessor vars were not showing the desired call location, and instead were
all showing the same line and function for inside the log call. So I used a
macro instead.
For the DBG_LOG macro, an important note is you need the two ## in front
of __VA_ARGS__ in order to prevent errors when no extra args were provided to
the macro. This might be gcc specific.</p>
<p>The result of this rework can be seen running in the rpcs3 emulator, though
I've confirmed it runs on hardware too:</p>

<img src="images/basic_entity_5_15_2021.png" width="600px"/>

<h3>05/22/2021</h3>
<p>Added pad class for the controller. Basic psl1ght API usage for the pad
is as follows:</p>
<pre><code>ioPadInit(7); // Idk what 7 means, TODO - look this up
...
padInfo info;
padData data;
int padnumber = 0;
while (true)
{
    ioPadGetInfo( &amp;info );
    if ( info.status[ padnumber ] )
    {
        ioPadGetData( padnumber, &amp;data );
        bool crossPressed = (bool)data.BTN_CROSS;
    }
}
</code></pre>

The list of available info from padData, based on the generated doxygen
from the ps3toolchain build is below (I could probably upload the generated
doxygen here, it'd be easier than opening the html locally...):
<pre><code>typedef struct _pad_data
 {
     s32 len;                                
     union{
         u16 button[MAX_PAD_CODES];          
         struct {
             u16 zeroes;                     
             unsigned int : 8;               
             unsigned int seven : 4;         
             unsigned int halflen : 4;       
             unsigned int : 8;               
             /* Button information */
             /* 0: UP, 1: DOWN */
             unsigned int BTN_LEFT : 1;      
             unsigned int BTN_DOWN : 1;      
             unsigned int BTN_RIGHT : 1;     
             unsigned int BTN_UP : 1;        
             unsigned int BTN_START : 1;     
             unsigned int BTN_R3 : 1;        
             unsigned int BTN_L3 : 1;        
             unsigned int BTN_SELECT : 1;    
             unsigned int : 8;               
             unsigned int BTN_SQUARE : 1;    
             unsigned int BTN_CROSS : 1;     
             unsigned int BTN_CIRCLE : 1;    
             unsigned int BTN_TRIANGLE : 1;  
             unsigned int BTN_R1 : 1;        
             unsigned int BTN_L1 : 1;        
             unsigned int BTN_R2 : 1;        
             unsigned int BTN_L2 : 1;        
             /* Analog nub information */
             /* 0x0000 - 0x00FF */
             unsigned int ANA_R_H : 16;
             unsigned int ANA_R_V : 16;
             unsigned int ANA_L_H : 16;
             unsigned int ANA_L_V : 16;
 
             /* Pressure-sensitive information */
             /* 0x0000 - 0x00FF */
             unsigned int PRE_RIGHT : 16;
             unsigned int PRE_LEFT : 16;
             unsigned int PRE_UP : 16;
             unsigned int PRE_DOWN : 16;
             unsigned int PRE_TRIANGLE : 16;
             unsigned int PRE_CIRCLE : 16;
             unsigned int PRE_CROSS : 16;
             unsigned int PRE_SQUARE : 16;
             unsigned int PRE_L1 : 16;
             unsigned int PRE_R1 : 16;
             unsigned int PRE_L2 : 16;
             unsigned int PRE_R2 : 16;
 
             /* Sensor information */
             /* 0x0000 - 0x03FF */
             unsigned int SENSOR_X : 16;
             unsigned int SENSOR_Y : 16;
             unsigned int SENSOR_Z : 16;
             unsigned int SENSOR_G : 16;
 
             /* BD remote information */
             unsigned int BTN_BDLEN : 16;    
             unsigned int BTN_BDCODE : 16;   
             u8 reserved[76];
         };
     };
 } padData;
</code></pre>

Then for my pad class, I made the following test to check button click/press/
vibration (called "actuators")/analog sticks:

<pre><code>Pad pad;
...
pad.Init( 0 ); // controller 0
..
while (true)
{
    pad.Update();
    if ( pad.IsHeld( Pad::CROSS ) ) {
        goto done;
    }
    
    // large actuator
    static unsigned short algVal;
    algVal = pad.GetLeftAnalogY();
    static unsigned short prevAlgVal = algVal;
    if ( algVal != prevAlgVal )
    {
        if ( algVal &gt; prevAlgVal &amp;&amp; algVal - prevAlgVal &gt; 5 )
        {
            pad.SetLargeActuator( algVal );
        }
        else if ( algVal < prevAlgVal && prevAlgVal - algVal > 5 )
        { 
            pad.SetLargeActuator( algVal );
        }
        DBG_LOG( "Alg X: %u", algVal );
    }
    prevAlgVal = algVal;

    // small actuator
    if ( pad.IsClicked( Pad::SQUARE ) )
    {
        static bool actVal = false;
        actVal = !actVal;
        pad.SetSmallActuator( actVal );
    }
    
    ...
}
</code></pre>

<p>Also created renderer class. Currently relies too heavily on rsxutil.h/cpp,
so a TODO is inspect those internals. Basic usage is as follows:</p>

<pre><code>Renderer renderer;
Entity entity;
renderer.Init();
while (1)
{
    renderer.BeginFrame();
    renderer.RenderEntity( entity );
    renderer.EndFrame();
}
</code></pre>

<p>RenderEntity() actually forwards the important drawing to the Entity
class; it sets render clip settings then just calls Entity::Render()</p>

<pre><code>void Renderer::RenderEntity( Entity&amp; entity )
{
    rsxSetUserClipPlaneControl(context,GCM_USER_CLIP_PLANE_DISABLE,
                                       GCM_USER_CLIP_PLANE_DISABLE,
                                       GCM_USER_CLIP_PLANE_DISABLE,
                                       GCM_USER_CLIP_PLANE_DISABLE,
                                       GCM_USER_CLIP_PLANE_DISABLE,
                                       GCM_USER_CLIP_PLANE_DISABLE);
    entity.Render();
}
</code></pre>

<p>To actually draw triangles, the process is quite OpenGL like:
you set vertex pointer attribs and then (in this case) draw indexed
triangles (code from Entity.cpp):</p>
<pre><code>rsxAddressToOffset( &amp;m_meshBuffer-&gt;vertices[0].pos, &amp;offset );
rsxBindVertexArrayAttrib( m_context,
                          GCM_VERTEX_ATTRIB_POS,
                          0,
                          offset,
                          sizeof( S3DVertex ),
                          3,
                          GCM_VERTEX_DATA_TYPE_F32,
                          GCM_LOCATION_RSX );

rsxAddressToOffset( &amp;m_meshBuffer-&gt;vertices[0].nrm, &amp;offset );
rsxBindVertexArrayAttrib( m_context,
                          GCM_VERTEX_ATTRIB_NORMAL,
                          0,
                          offset,
                          sizeof( S3DVertex ),
                          3,
                          GCM_VERTEX_DATA_TYPE_F32,
                          GCM_LOCATION_RSX );

rsxAddressToOffset( &amp;m_meshBuffer-&gt;vertices[0].u, &amp;offset );
rsxBindVertexArrayAttrib( m_context,
                          GCM_VERTEX_ATTRIB_TEX0,
                          0,
                          offset,
                          sizeof( S3DVertex ),
                          2,
                          GCM_VERTEX_DATA_TYPE_F32,
                          GCM_LOCATION_RSX );

rsxAddressToOffset( &amp;m_meshBuffer-&gt;indices[0], &amp;offset );
rsxDrawIndexArray( m_context,
                   GCM_TYPE_TRIANGLES,
                   offset,
                   m_meshBuffer-&gt;cnt_indices,
                   GCM_INDEX_TYPE_16B,
                   GCM_LOCATION_RSX );

</code></pre>

<p>Next, I tested file I/O. This is a luxury compared to PS2 and PS1 - there
is a PS3 OS which provides filesystem access for us! At first, I tried to
program a test file location relative to the SELF executable directory, but
the test.txt file failed to open. I added a DEFINE for the assets directory
instead so the absolute path was used:</p>

<pre><code>Makefile:
  ASSETS_DIR  :=  /dev_hdd0/rsxtest/game/assets
  TARGET      :=  game/rsxtest
  ...
  CFLAGS      =   -Wall -mcpu=cell $(MACHDEP) $(INCLUDE) -DASSETS_DIR=\"$(ASSETS_DIR)\"

Code:
 static void fileTest()
  {
      std::string line;
      std::ifstream testFile( ASSETS_DIR"/test.txt" );
      if ( !testFile.is_open() ) {
          DBG_LOG( "Failed to open assets/test.txt" );
          return;
      }
  
      for (; std::getline( testFile, line ); )
      {
          DBG_LOG( line.c_str() );
      }
  }
</code></pre>

<p>To access the PS3 filesystem remotely, we can use the FTP server built into
the PS3 CFW. I can access the ftp server from my computer by mounting it in
a local directory using curlftpfs; then it's just a matter of copying the
files over:

<pre><code>curlftpfs ftp://192.168.0.14 ~/ps3_ftp/ # mount the ftp server
cp -r game ~/ps3_ftp/dev_hdd0/rsxtest/
</code></pre>

<p>On the ps3 side, to launch the game, we can find the self executable
in the multiman explorer and launch it from there (although ps3load should
still work, I think...)</p>

<img src="images/ps3_filesystem_5_22_2021.jpg" width="500px"/>

<h3>05/23/2021</h3>

<p>Got an untextured MD2 model working by modifying the MD2 model code from
<a href="../bgn_opengl_game_prg/index.html">Beginning OpenGL Game Programming</a>.

<p>I first ran into a file endianness issue:</p>
<img src="images/md2_endian_error_5_23_2021.png"/>
<p>The version field of the MD2 header (a 32bit integer) was being read as
0x08000000 instead of 0x00000008. I forgot that the Ps3 Cell CPU is big endian,
whereas my x86_64 desktop is little endian. The MD2 file fields are stored
as little endian as well. I chose to handle this on the PS3 by converting the
read in file fields from little to big endian during load:</p>
<pre><code>Md2Model.h:

// little endian to big endian
inline int32_t lend2bend32( int32_t lend )
{
    char* ptr = (char*)&lend;
    return (ptr[3] &lt;&lt; 24) |
           (ptr[2] &lt;&lt; 16) |
           (ptr[1] &lt;&lt; 8)  |
           (ptr[0]);
}
inline float lend2bend32f( float lend )
{   
    float res;
    char* ptr = (char*)&lend;
    char* rPtr = (char*)&res;
    rPtr[0] = ptr[3];
    rPtr[1] = ptr[2];
    rPtr[2] = ptr[1];
    rPtr[3] = ptr[0];
    return res;
}
inline int16_t lend2bend16( int16_t lend )
{
    char* ptr = (char*)&lend;
    return (ptr[1] &lt;&lt; 8) |
           (ptr[0]);
}

Md2Model.cpp:
...
READ_DATA( lend2bend32( header.skinOffset ), skins, lend2bend32( header.numSkins ), Skin);
READ_DATA( lend2bend32( header.texCoordOffset ), md2TexCoords, lend2bend32( header.numTexCoords )
READ_DATA( lend2bend32( header.triangleOffset ), triangles, lend2bend32( header.numTriangles ), T

for ( TexCoord&amp; tc : md2TexCoords )
{
    tc.s = lend2bend16( tc.s );
    tc.t = lend2bend16( tc.t );
}   
for ( Triangle&amp; tr : triangles )
{
    tr.vertIndex[0] = lend2bend16( tr.vertIndex[0] );
    tr.vertIndex[1] = lend2bend16( tr.vertIndex[1] );
    tr.vertIndex[2] = lend2bend16( tr.vertIndex[2] );
    tr.texCoordIndex[0] = lend2bend16( tr.texCoordIndex[0] );
    tr.texCoordIndex[1] = lend2bend16( tr.texCoordIndex[1] );
    tr.texCoordIndex[2] = lend2bend16( tr.texCoordIndex[2] );
}  
...
// and similar for other locations with int16_t/int32_t/float
</code></pre>

<p>I also had to swap the Vec3 class with Vector3 (from the psl1ght library),
and define a basic Vector2 struct:</p>
<pre><code>struct KeyFrame
{
    f32 scale[3];     // use to multiply and add Vertex::v
    f32 translate[3];
    char name[16];
    std::vector<Vertex> md2Vertices;
    std::vector<Vector3> vertices; // converted result vertices
};
...
struct Vector2
{
    f32 u,v;
};
</code></pre>

<p>Then I replaced the opengl buffering with rsx memory buffering like
in the torus/sphere classes:</p>

<pre><code>
genBuffers:

m_meshBuffer-&gt;cnt_vertices = interpolatedFrame.vertices.size();
m_meshBuffer-&gt;vertices =
    (S3DVertex*)rsxMemalign( 128, 
                             m_meshBuffer-&gt;cnt_vertices * sizeof(S3DVertex) );
if ( !m_meshBuffer-&gt;vertices ) {
    DBG_LOG( "Failed to alloc vertices\n" );
    return false; 
}   
m_meshBuffer-&gt;indices = nullptr;
if ( texCoords.size() != interpolatedFrame.vertices.size() ) {
    DBG_LOG( "Tex coords size != vertices size (%lu, %lu)\n",
            texCoords.size(), interpolatedFrame.vertices.size() );
    return false;
}
for ( u32 i = 0; i < m_meshBuffer->cnt_vertices; ++i )
{
    Vector3&amp; pos = interpolatedFrame.vertices[i];
    m_meshBuffer-&gt;vertices[i] = S3DVertex( pos.getX(), pos.getY(), pos.getZ(),
                                           0.0f, 1.0f, 0.0f, // TODO - normals
                                           texCoords[i].u, texCoords[i].v );
}
return true;

Update:

...
// Update RSX memory
for ( u32 i = 0; i < m_meshBuffer->cnt_vertices; ++i )
{
    Vector3&amp; pos = interpolatedFrame.vertices[i];
    m_meshBuffer-&gt;vertices[i] = S3DVertex( pos.getX(), pos.getY(), pos.getZ(),
                                           0.0f, 1.0f, 0.0f, // TODO - normals
                                           texCoords[i].u, texCoords[i].v );
}
</code></pre>

<p>The md2 model also needs to be drawn with triangle arrays instead of indices.
I found rsxDrawVertexArray() in the psl1ght doxygen on the same page as
rsxDrawIndexArray() used previously, on the commands.h file reference:</p>
<img src="images/rsxdrawvertexarray_doxygen_5_23_2021.png"/>

<p>Then a slight modification to Entity::Render() to check wether to draw
with indices or arrays:</p>
<pre><code>...
if ( m_meshBuffer-&amp;gt;indices != nullptr )
{
    rsxAddressToOffset( &amp;m_meshBuffer-&amp;gt;indices[0], &amp;offset );
    rsxDrawIndexArray( m_context,
                       GCM_TYPE_TRIANGLES,        // u32 type
                       offset,                    // u32 offset
                       m_meshBuffer-&amp;gt;cnt_indices, // u32 count
                       GCM_INDEX_TYPE_16B,        // u32 data_type
                       GCM_LOCATION_RSX );        // u32 location
}
else
{
    rsxDrawVertexArray( m_context,
                        GCM_TYPE_TRIANGLES,
                        0,
                        m_meshBuffer-&gt;cnt_vertices );
}
</code></pre>

<p>Finally, in order to update the md2's animation, I added a GameTimer
class in main.cpp, based off ppu/include/sys/systime.h sysGetCurrentTime()</p>
<pre><code>class GameTimer
{
public:
    GameTimer()
    {   
        GetCurSecNsec( &amp;m_lastSec, &amp;m_lastNsec );
        m_FPS = 0.0f;
    }   
    ~GameTimer()
    {}  
    void Update()
    {   
        u64 curSec;
        u64 curNsec;
        GetCurSecNsec( &amp;curSec, &amp;curNsec );

        u64 secDiff = curSec - m_lastSec;
        u64 nsecDiff = (curNsec &lt; m_lastNsec) ? m_lastNsec - curNsec : curNsec - m_lastNsec;

        m_deltaMs = (float( secDiff ) * 1000.0f) +
                    (float( nsecDiff ) / 1000000.0f);
        m_lastSec = curSec;
        m_lastNsec = curNsec;

        ++m_framesCount;
        m_fpsTimeCount += m_deltaMs;
        if ( m_fpsTimeCount / 1000.0f &gt;= m_fpsDuration )
        {
            m_FPS = ( m_fpsTimeCount / 1000.0f ) * m_framesCount;
            m_framesCount = 0;
            m_fpsTimeCount = 0.0f;
        }
    }
    float GetDeltaMS() { return m_deltaMs; }
    float GetFPS() { return m_FPS; }
private:
    float m_deltaMs; // time passed since last update
    float m_FPS;
    u64 m_lastSec;
    u64 m_lastNsec;
    u32 m_framesCount = 0;
    float m_fpsTimeCount = 0.0f;
    const float m_fpsDuration = 1.0f; // seconds until update fps

    inline void GetCurSecNsec( u64* sec, u64* nsec )
    {
        sysGetCurrentTime( sec, nsec );
    }
};
</code></pre>

<p>The code in main to then load and draw the md2 model is:</p>
<pre><code>static Md2Model g_Ogro;
...
    if ( !g_Ogro.Init( g_Renderer.GetGcmContext() ) ) {
        DBG_LOG( "Failed to init md2 model ogro\n" );
        return;
    }
    if ( !g_Ogro.Load( ASSETS_DIR"/models/Ogro/tris.md2" ) ) {
        DBG_LOG( "Failed to load assets/models/Ogro/tris.md2\n" );
        return;
    } else {
        DBG_LOG( "Success loading assets/models/Ogro/tris.md2\n" );
    }
    g_Ogro.SetAnimation( Md2Model::Animation::Idle );
...
g_Timer.Update();
g_Ogro.Update( g_Timer.GetDeltaMS() );
...
modelMatrix = Matrix4::scale( Vector3( 0.25f, 0.25f, 0.25f ) );
modelMatrix.setTranslation(Vector3(3.0f,0.0f,-8.0f));

modelMatrixIT = inverse(modelMatrix);
modelViewMatrix = transpose(viewMatrix*modelMatrix);

objEyePos = modelMatrixIT*eye_pos;

g_Shader.Use();
g_Shader.SetVertexProgParam( "projMatrix", (float*)&amp;g_ProjMatrix );
g_Shader.SetVertexProgParam( "modelViewMatrix", (float*)&amp;modelViewMatrix );

g_Renderer.RenderEntity( g_Ogro );
</code></pre>

<p>Which gives us an unproperly textured model:</p>

<img src="images/untextured_md2_5_23_2021.gif"/>

<p>As a side note, I found you can added files to the rpcs3 emulator by
simply placing files in the appropriate directory in the same folder
as the emulator executable:</p>

<img src="images/rpcs3_folder_layout_5_23_2021.png"/>

<p>Next TODO is to get the proper texture loaded and used</p>

<p>
<a href="../../index.html">&lt;-- Back to Home</a>
</p>

</div> <!-- contentDiv -->
</div> <!-- bodyDiv -->

</body>
</html>
