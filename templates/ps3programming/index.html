<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>BJ's Website</title>
  <link rel="stylesheet" type="text/css" href="../../site.css"/>
  
</head>
<body>

<div id="bodyDiv">

<div id="contentDiv">

<h1>PS3 Programming Log</h1>
<img alt="PS2 Logo" style="float:right; margin:5px;" src="https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Flogonoid.com%2Fimages%2Fplaystation-3-logo.png&f=1&nofb=1" width="400px"/>

<p>My working log for learning programming for the Playstation 3. Inspired
by <a href="https://research.ncl.ac.uk/game/mastersdegree/">Newcastle University's
Computer Game Engineering Content</a> where they have a few sections on PS3 programming.
Unfortunately, they seem to use the official SONY PS3 Devkit, which of course we don't
have access too. There is however an open source ps3sdk we can use:
<a href="https://github.com/ps3dev">https://github.com/ps3dev</a>. I've followed so far
the first introduction section from the Newcastle content and it seems like a good resource;
the only drawback is it's Windows and Visual Studio oriented. (Another future project TODO -
convert their example code to SDL/GLEW for Linux support!)</p>

<p>For PS3 my current goal is
to get MD5 skeletal animation working
<a href="https://research.ncl.ac.uk/game/mastersdegree/graphicsforgames/skeletalanimation/">
from the NewCastle tutorial</a>, and possibly 
the GLTF skeletal animation from <a href="https://www.amazon.com/Hands-Game-Animation-Programming-implementation/dp/1800208081">
Hands-On C++ Game Animation Programming</a>. Also, it'd be cool to get
<a href="https://github.com/gzorin/RSXGL">RSXGL</a> working, which is an OpenGL 3.1
implementation, but I haven't had any luck so far.</p>

<p>The source code is currently here: <a href="https://bitbucket.org/williamblair/ps3devprogs">https://bitbucket.org/williamblair/ps3devprogs</a></p>

<h3>05/15/2021</h3>

<p>Looking through the
<a href="https://github.com/ps3dev/PSL1GHT/tree/master/samples/graphics/rsxtest">
psl1ght graphics example</a>. Seems actually pretty similar to OpenGL: we have shaders,
buffer attributes, texture formats, etc...
</p>
<p>The shaders are NOT compiled and loaded at runtime like in OpenGL; instead they are
pre-compiled at the same time as the main program and stored as byte arrays and included
as C headers.</p>
<p>The shader language seems pretty similar to GLSL except programs take in
a bunch of function arguments intead of global vars:</p>
<pre><code>void main
(
    float3 vertexPosition : POSITION,
    float3 vertexNormal : NORMAL,
    float2 vertexTexcoord : TEXCOORD0,
    
    uniform float4x4 projMatrix,
    uniform float4x4 modelViewMatrix,
    
    out float4 ePosition : POSITION,
    out float4 oPosition : TEXCOORD0,
    out float3 oNormal : TEXCOORD1,
    out float2 oTexcoord : TEXCOORD2
)
{
    ePosition = mul(mul(projMatrix,modelViewMatrix),float4(vertexPosition,1.0f));
    
    oPosition = float4(vertexPosition,1.0f);
    oNormal = vertexNormal;
    oTexcoord = vertexTexcoord;
}
</code></pre>

<p>Vertex buffer data seems to be stored on GPU memory but accessible from the CPU.
The memory is allocated via rsxMemalign() and then vertex data is copied into it.
There is an 'offset' associated with this allocation used as arguments to other functions;
I'm assuming this is like the address of the memory block within GPU memory.</p>
<pre><code>m_meshBuffer->vertices = (S3DVertex*)rsxMemalign(128,m_meshBuffer->cnt_vertices*sizeof(S3DVertex));
...
m_meshBuffer->vertices[i] = S3DVertex(pos.getX(),pos.getY(),pos.getZ(),normal.getX(),normal.getY(),normal.getZ(),tu,static_cast<f32>(ay*RECIPROCAL_PI));
u32 offset = 0;    
rsxAddressToOffset( &m_meshBuffer->vertices[0].pos, &offset );
</code></pre>
<p>The S3DVertex and SBuffer classes are included with the psl1ght sample as custom objects (mesh.h), so we
don't have to use those if we don't want to.</p>
<p>As a side note, the main CPU is the PowerPC Processor Unit (PPU) and then there are 
eight SPUs to execute separate programs to run in parallel if desired (see 
<a href="https://mirrors.edge.kernel.org/pub/linux/kernel/people/geoff/cell/ps3-linux-docs/CellProgrammingTutorial/BasicsOfCellArchitecture.html">here</a>).
RSX stands for reality synthesizer and is the PS3 GPU (see <a href="https://www.psdevwiki.com/ps3/RSX">here</a>.)
</p>
<p>The compiled program results in a .elf file (similar to the PS2), but for the PS3 this
needs to be converted into a .self file which I think is an encrypted version of the .elf.
Using ps3load with the elf file didn't seem to work but using the .self file did. Conversion
to a .self is done automatically with the ps1light sample makefile.</p>

<p>I remorked the sample code to remove the lighting (to simplify things), then made the
following C++ classes:</p>
<ul>
<li>Shader</li>
<li>Texture</li>
<li>Entity
    <ul>
     <li>Sphere</li>
     <li>Torus</li>
     <li>Cube</li>
    </ul>
</li>
</ul>

<p>Rendering an entity then works the same as opengl, where you set shader
and vertex buffer attributes, then draw indexed arrays:</p>
<pre><code>g_Shader.Use();
g_Shader.SetVertexProgParam( "projMatrix", (float*)&P );
g_Shader.SetVertexProgParam( "modelViewMatrix", (float*)&modelViewMatrix );
...
g_Sphere.Render();
</code></pre>

<p>TODO is to make a rendering class, also have a single shader SetAttribute
function for both vertex shader and fragment shader attribs.
I also made a Logging namespace and macro which logs to both
TTY/stdout and the debug font sample to the screen:</p>
<pre><code>#define DBG_LOG(format, ...)                                            \
    sprintf( Log::dbgPrintStr, "%s:%d: ", __FILE__, __LINE__ );         \
    Log::len = strlen( Log::dbgPrintStr );                              \
    sprintf( &Log::dbgPrintStr[ Log::len ], format, ##__VA_ARGS__ );    \
                                                                        \
    printf( Log::dbgPrintStr );                                         \
                                                                        \
    Log::dbgLogHistory.push_back( Log::dbgPrintStr );                   \
    if ( Log::dbgLogHistory.size() > LOG_HISTORY_LEN ) {                \
        Log::dbgLogHistory.pop_front();                                 \
    }
</code></pre>

<p>I originally tried an inline function but that resulted in the function
not actually being able to be inlined, and thus the __FILE__ and __LINE__
preprocessor vars were not showing the desired call location, and instead were
all showing the same line and function for inside the log call. So I used a
macro instead.
For the DBG_LOG macro, an important note is you need the two ## in front
of __VA_ARGS__ in order to prevent errors when no extra args were provided to
the macro. This might be gcc specific.</p>
<p>The result of this rework can be seen running in the rpcs3 emulator, though
I've confirmed it runs on hardware too:</p>

<img src="images/basic_entity_5_15_2021.png" width="600px"/>

<h3>05/22/2021</h3>
<p>Added pad class for the controller. Basic psl1ght API usage for the pad
is as follows:</p>
<pre><code>ioPadInit(7); // Idk what 7 means, TODO - look this up
...
padInfo info;
padData data;
int padnumber = 0;
while (true)
{
    ioPadGetInfo( &info );
    if ( info.status[ padnumber ] )
    {
        ioPadGetData( padnumber, &data );
        bool crossPressed = (bool)data.BTN_CROSS;
    }
}
</code></pre>

The list of available info from padData, based on the generated doxygen
from the ps3toolchain build is below (I could probably upload the generated
doxygen here, it'd be easier than opening the html locally...):
<pre><code>typedef struct _pad_data
 {
     s32 len;                                
     union{
         u16 button[MAX_PAD_CODES];          
         struct {
             u16 zeroes;                     
             unsigned int : 8;               
             unsigned int seven : 4;         
             unsigned int halflen : 4;       
             unsigned int : 8;               
             /* Button information */
             /* 0: UP, 1: DOWN */
             unsigned int BTN_LEFT : 1;      
             unsigned int BTN_DOWN : 1;      
             unsigned int BTN_RIGHT : 1;     
             unsigned int BTN_UP : 1;        
             unsigned int BTN_START : 1;     
             unsigned int BTN_R3 : 1;        
             unsigned int BTN_L3 : 1;        
             unsigned int BTN_SELECT : 1;    
             unsigned int : 8;               
             unsigned int BTN_SQUARE : 1;    
             unsigned int BTN_CROSS : 1;     
             unsigned int BTN_CIRCLE : 1;    
             unsigned int BTN_TRIANGLE : 1;  
             unsigned int BTN_R1 : 1;        
             unsigned int BTN_L1 : 1;        
             unsigned int BTN_R2 : 1;        
             unsigned int BTN_L2 : 1;        
             /* Analog nub information */
             /* 0x0000 - 0x00FF */
             unsigned int ANA_R_H : 16;
             unsigned int ANA_R_V : 16;
             unsigned int ANA_L_H : 16;
             unsigned int ANA_L_V : 16;
 
             /* Pressure-sensitive information */
             /* 0x0000 - 0x00FF */
             unsigned int PRE_RIGHT : 16;
             unsigned int PRE_LEFT : 16;
             unsigned int PRE_UP : 16;
             unsigned int PRE_DOWN : 16;
             unsigned int PRE_TRIANGLE : 16;
             unsigned int PRE_CIRCLE : 16;
             unsigned int PRE_CROSS : 16;
             unsigned int PRE_SQUARE : 16;
             unsigned int PRE_L1 : 16;
             unsigned int PRE_R1 : 16;
             unsigned int PRE_L2 : 16;
             unsigned int PRE_R2 : 16;
 
             /* Sensor information */
             /* 0x0000 - 0x03FF */
             unsigned int SENSOR_X : 16;
             unsigned int SENSOR_Y : 16;
             unsigned int SENSOR_Z : 16;
             unsigned int SENSOR_G : 16;
 
             /* BD remote information */
             unsigned int BTN_BDLEN : 16;    
             unsigned int BTN_BDCODE : 16;   
             u8 reserved[76];
         };
     };
 } padData;
</code></pre>

Then for my pad class, I made the following test to check button click/press/
vibration (called "actuators")/analog sticks:

<pre><code>Pad pad;
...
pad.Init( 0 ); // controller 0
..
while (true)
{
    pad.Update();
    if ( pad.IsHeld( Pad::CROSS ) ) {
        goto done;
    }
    
    // large actuator
    static unsigned short algVal;
    algVal = pad.GetLeftAnalogY();
    static unsigned short prevAlgVal = algVal;
    if ( algVal != prevAlgVal )
    {
        if ( algVal > prevAlgVal && algVal - prevAlgVal > 5 )
        {
            pad.SetLargeActuator( algVal );
        }
        else if ( algVal < prevAlgVal && prevAlgVal - algVal > 5 )
        { 
            pad.SetLargeActuator( algVal );
        }
        DBG_LOG( "Alg X: %u", algVal );
    }
    prevAlgVal = algVal;

    // small actuator
    if ( pad.IsClicked( Pad::SQUARE ) )
    {
        static bool actVal = false;
        actVal = !actVal;
        pad.SetSmallActuator( actVal );
    }
    
    ...
}
</code></pre>

<p>Also created renderer class. Currently relies too heavily on rsxutil.h/cpp,
so a TODO is inspect those internals. Basic usage is as follows:</p>

<pre><code>Renderer renderer;
Entity entity;
renderer.Init();
while (1)
{
    renderer.BeginFrame();
    renderer.RenderEntity( entity );
    renderer.EndFrame();
}
</code></pre>

<p>RenderEntity() actually forwards the important drawing to the Entity
class; it sets render clip settings then just calls Entity::Render()</p>

<pre><code>void Renderer::RenderEntity( Entity& entity )
{
    rsxSetUserClipPlaneControl(context,GCM_USER_CLIP_PLANE_DISABLE,
                                       GCM_USER_CLIP_PLANE_DISABLE,
                                       GCM_USER_CLIP_PLANE_DISABLE,
                                       GCM_USER_CLIP_PLANE_DISABLE,
                                       GCM_USER_CLIP_PLANE_DISABLE,
                                       GCM_USER_CLIP_PLANE_DISABLE);
    entity.Render();
}
</code></pre>

<p>To actually draw triangles, the process is quite OpenGL like:
you set vertex pointer attribs and then (in this case) draw indexed
triangles (code from Entity.cpp):</p>
<pre><code>rsxAddressToOffset( &m_meshBuffer->vertices[0].pos, &offset );
rsxBindVertexArrayAttrib( m_context,
                          GCM_VERTEX_ATTRIB_POS,
                          0,
                          offset,
                          sizeof( S3DVertex ),
                          3,
                          GCM_VERTEX_DATA_TYPE_F32,
                          GCM_LOCATION_RSX );

rsxAddressToOffset( &m_meshBuffer->vertices[0].nrm, &offset );
rsxBindVertexArrayAttrib( m_context,
                          GCM_VERTEX_ATTRIB_NORMAL,
                          0,
                          offset,
                          sizeof( S3DVertex ),
                          3,
                          GCM_VERTEX_DATA_TYPE_F32,
                          GCM_LOCATION_RSX );

rsxAddressToOffset( &m_meshBuffer->vertices[0].u, &offset );
rsxBindVertexArrayAttrib( m_context,
                          GCM_VERTEX_ATTRIB_TEX0,
                          0,
                          offset,
                          sizeof( S3DVertex ),
                          2,
                          GCM_VERTEX_DATA_TYPE_F32,
                          GCM_LOCATION_RSX );

rsxAddressToOffset( &m_meshBuffer->indices[0], &offset );
rsxDrawIndexArray( m_context,
                   GCM_TYPE_TRIANGLES,
                   offset,
                   m_meshBuffer->cnt_indices,
                   GCM_INDEX_TYPE_16B,
                   GCM_LOCATION_RSX );

</code></pre>

<p>Next, I tested file I/O. This is a luxury compared to PS2 and PS1 - there
is a PS3 OS which provides filesystem access for us! At first, I tried to
program a test file location relative to the SELF executable directory, but
the test.txt file failed to open. I added a DEFINE for the assets directory
instead so the absolute path was used:</p>

<pre><code>Makefile:
  ASSETS_DIR  :=  /dev_hdd0/rsxtest/game/assets
  TARGET      :=  game/rsxtest
  ...
  CFLAGS      =   -Wall -mcpu=cell $(MACHDEP) $(INCLUDE) -DASSETS_DIR=\"$(ASSETS_DIR)\"

Code:
 static void fileTest()
  {
      std::string line;
      std::ifstream testFile( ASSETS_DIR"/test.txt" );
      if ( !testFile.is_open() ) {
          DBG_LOG( "Failed to open assets/test.txt" );
          return;
      }
  
      for (; std::getline( testFile, line ); )
      {
          DBG_LOG( line.c_str() );
      }
  }
</code></pre>

<p>To access the PS3 filesystem remotely, we can use the FTP server built into
the PS3 CFW. I can access the ftp server from my computer by mounting it in
a local directory using curlftpfs; then it's just a matter of copying the
files over:

<pre><code>curlftpfs ftp://192.168.0.14 ~/ps3_ftp/ # mount the ftp server
cp -r game ~/ps3_ftp/dev_hdd0/rsxtest/
</code></pre>

<p>On the ps3 side, to launch the game, we can find the self executable
in the multiman explorer and launch it from there (although ps3load should
still work, I think...)</p>

<img src="images/ps3_filesystem_5_22_2021.jpg" width="500px"/>

<p>
<a href="../../index.html">&lt;-- Back to Home</a>
</p>

</div> <!-- contentDiv -->
</div> <!-- bodyDiv -->

</body>
</html>
